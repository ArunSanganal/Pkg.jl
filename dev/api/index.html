<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>11. API Reference · Pkg.jl</title><link rel="canonical" href="https://julialang.github.io/Pkg.jl/v1/api/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Pkg.jl logo"/></a><h1>Pkg.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../"><strong>1.</strong> Introduction</a></li><li><a class="toctext" href="../getting-started/"><strong>2.</strong> Getting Started</a></li><li><a class="toctext" href="../managing-packages/"><strong>3.</strong> Managing Packages</a></li><li><a class="toctext" href="../environments/"><strong>4.</strong> Working with Environments</a></li><li><a class="toctext" href="../creating-packages/"><strong>5.</strong> Creating Packages</a></li><li><a class="toctext" href="../compatibility/"><strong>6.</strong> Compatibility</a></li><li><a class="toctext" href="../registries/"><strong>7.</strong> Registries</a></li><li><a class="toctext" href="../glossary/"><strong>8.</strong> Glossary</a></li><li><a class="toctext" href="../toml-files/"><strong>9.</strong> <code>Project.toml</code> and <code>Manifest.toml</code></a></li><li><a class="toctext" href="../repl/"><strong>10.</strong> REPL Mode Reference</a></li><li class="current"><a class="toctext" href><strong>11.</strong> API Reference</a><ul class="internal"><li><a class="toctext" href="#Package-API-Reference-1">Package API Reference</a></li><li><a class="toctext" href="#Registry-API-Reference-1">Registry API Reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href><strong>11.</strong> API Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>11. API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1"><strong>11.</strong> API Reference</a></h1><p>This section describes the function interface, or &quot;API mode&quot;, for interacting with Pkg.jl. The function API is recommended for non-interactive usage, for example in scripts.</p><h2><a class="nav-anchor" id="Package-API-Reference-1" href="#Package-API-Reference-1">Package API Reference</a></h2><p>In the REPL mode, packages (with associated version, UUID, URL etc) are parsed from strings, for example <code>&quot;Package#master&quot;</code>,<code>&quot;Package@v0.1&quot;</code>, <code>&quot;www.mypkg.com/MyPkg#my/feature&quot;</code>.</p><p>In the API mode, it is possible to use strings as arguments for simple commands (like <code>Pkg.add([&quot;PackageA&quot;, &quot;PackageB&quot;])</code>, but more complicated commands, which e.g. specify URLs or version range, require the use of a more structured format over strings. This is done by creating an instance of <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> which is passed in to functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.PackageSpec" href="#Pkg.PackageSpec"><code>Pkg.PackageSpec</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">PackageSpec(name::String, [uuid::UUID, version::VersionNumber])
PackageSpec(; name, url, path, rev, version, mode, level)</code></pre><p>A <code>PackageSpec</code> is a representation of a package with various metadata. This includes:</p><ul><li>The <code>name</code> of the package.</li><li>The package&#39;s unique <code>uuid</code>.</li><li>A <code>version</code> (for example when adding a package). When upgrading, can also be an instance of</li></ul><p>the enum <a href="#Pkg.UpgradeLevel"><code>UpgradeLevel</code></a>.</p><ul><li>A <code>url</code> and an optional git <code>rev</code>ision. <code>rev</code> can be a branch name or a git commit SHA1.</li><li>A local <code>path</code>. This is equivalent to using the <code>url</code> argument but can be more descriptive.</li><li>A <code>mode</code>, which is an instance of the enum <a href="#Pkg.PackageMode"><code>PackageMode</code></a>, with possible values <code>PKGMODE_PROJECT</code></li></ul><p>(the default) or <code>PKGMODE_MANIFEST</code>. Used in e.g. <a href="#Pkg.rm"><code>Pkg.rm</code></a>.</p><p>Most functions in Pkg take a <code>Vector</code> of <code>PackageSpec</code> and do the operation on all the packages in the vector.</p><p>Below is a comparison between the REPL version and the API version:</p><table><tr><th style="text-align: left"><code>REPL</code></th><th style="text-align: left"><code>API</code></th></tr><tr><td style="text-align: left"><code>Package</code></td><td style="text-align: left"><code>PackageSpec(&quot;Package&quot;)</code></td></tr><tr><td style="text-align: left"><code>Package@0.2</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, version=&quot;0.2&quot;)</code></td></tr><tr><td style="text-align: left"><code>Package=a67d...</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, uuid=&quot;a67d...&quot;)</code></td></tr><tr><td style="text-align: left"><code>Package#master</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, rev=&quot;master&quot;)</code></td></tr><tr><td style="text-align: left"><code>local/path#feature</code></td><td style="text-align: left"><code>PackageSpec(path=&quot;local/path&quot;; rev=&quot;feature&quot;)</code></td></tr><tr><td style="text-align: left"><code>www.mypkg.com</code></td><td style="text-align: left"><code>PackageSpec(url=&quot;www.mypkg.com&quot;)</code></td></tr><tr><td style="text-align: left"><code>--manifest Package</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, mode=PKGSPEC_MANIFEST)</code></td></tr><tr><td style="text-align: left"><code>--major Package</code></td><td style="text-align: left"><code>PackageSpec(name=&quot;Package&quot;, version=PKGLEVEL_MAJOR)</code></td></tr></table></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L335-L366">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.PackageMode" href="#Pkg.PackageMode"><code>Pkg.PackageMode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PackageMode</code></pre><p>An enum with the instances</p><ul><li><code>PKGMODE_MANIFEST</code></li><li><code>PKGMODE_PROJECT</code></li></ul><p>Determines if operations should be made on a project or manifest level. Used as an argument to  <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> or as an argument to <a href="#Pkg.rm"><code>Pkg.rm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L49-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.UpgradeLevel" href="#Pkg.UpgradeLevel"><code>Pkg.UpgradeLevel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UpgradeLevel</code></pre><p>An enum with the instances</p><ul><li><code>UPLEVEL_FIXED</code></li><li><code>UPLEVEL_PATCH</code></li><li><code>UPLEVEL_MINOR</code></li><li><code>UPLEVEL_MAJOR</code></li></ul><p>Determines how much a package is allowed to be updated. Used as an argument to  <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a> or as an argument to <a href="#Pkg.update"><code>Pkg.update</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L63-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.add" href="#Pkg.add"><code>Pkg.add</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.add(pkg::Union{String, Vector{String}})
Pkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Add a package to the current project. This package will be available by using the <code>import</code> and <code>using</code> keywords in the Julia REPL, and if the current project is a package, also inside that package.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.add(&quot;Example&quot;) # Add a package from registry
Pkg.add(PackageSpec(name=&quot;Example&quot;, version=&quot;0.3&quot;)) # Specify version; latest release in the 0.3 series
Pkg.add(PackageSpec(name=&quot;Example&quot;, version=&quot;0.3.1&quot;)) # Specify version; exact release
Pkg.add(PackageSpec(url=&quot;https://github.com/JuliaLang/Example.jl&quot;, rev=&quot;master&quot;)) # From url to remote gitrepo
Pkg.add(PackageSpec(url=&quot;/remote/mycompany/juliapackages/OurPackage&quot;))` # From path to local gitrepo</code></pre><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L79-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.develop" href="#Pkg.develop"><code>Pkg.develop</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.develop(pkg::Union{String, Vector{String}})
Pkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}})</code></pre><p>Make a package available for development by tracking it by path. If <code>pkg</code> is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable <code>JULIA_PKG_DEVDIR</code>, with <code>.julia/dev</code> as the default.</p><p>If <code>pkg</code> is given as a local path, the package at that path will be tracked.</p><p><strong>Examples</strong></p><pre><code class="language-julia"># By name
Pkg.develop(&quot;Example&quot;)

# By url
Pkg.develop(PackageSpec(url=&quot;https://github.com/JuliaLang/Compat.jl&quot;))

# By path
Pkg.develop(PackageSpec(path=&quot;MyJuliaPackages/Package.jl&quot;))</code></pre><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L236-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.activate" href="#Pkg.activate"><code>Pkg.activate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.activate([s::String]; shared::Bool=false)</code></pre><p>Activate the environment at <code>s</code>. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:</p><ul><li>If <code>shared</code> is <code>true</code>, the first existing environment named <code>s</code> from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.</li><li>If <code>s</code> is an existing path, then activate the environment at that path.</li><li>If <code>s</code> is a package in the current project and <code>s</code> is tracking a path, then activate the environment at the tracked path.</li><li>Otherwise, <code>s</code> is interpreted as a non-existing path, which is then activated.</li></ul><p>If no argument is given to <code>activate</code>, then activate the home project. The home project is specified by either the <code>--project</code> command line option to the julia executable, or the <code>JULIA_PROJECT</code> environment variable.</p><p><strong>Examples</strong></p><pre><code class="language-none">Pkg.activate()
Pkg.activate(&quot;local/path&quot;)
Pkg.activate(&quot;MyDependency&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L306-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.rm" href="#Pkg.rm"><code>Pkg.rm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.rm(pkg::Union{String, Vector{String}})
Pkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Remove a package from the current project. If the <code>mode</code> of <code>pkg</code> is <code>PKGMODE_MANIFEST</code> also remove it from the manifest including all recursive dependencies of <code>pkg</code>.</p><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>, <a href="#Pkg.PackageMode"><code>PackageMode</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L116-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.update" href="#Pkg.update"><code>Pkg.update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT)
Pkg.update(pkg::Union{String, Vector{String}})
Pkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Update a package <code>pkg</code>. If no posistional argument is given, update all packages in the manifest if <code>mode</code> is <code>PKGMODE_MANIFEST</code> and packages in both manifest and project if <code>mode</code> is <code>PKGMODE_PROJECT</code>. If no positional argument is given, <code>level</code> can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).</p><p>See also <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>, <a href="#Pkg.PackageMode"><code>PackageMode</code></a>, <a href="#Pkg.UpgradeLevel"><code>UpgradeLevel</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L128-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.test" href="#Pkg.test"><code>Pkg.test</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.test(; coverage::Bool=false)
Pkg.test(pkg::Union{String, Vector{String}; coverage::Bool=false)
Pkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; coverage::Bool=false)</code></pre><p>Run the tests for package <code>pkg</code>, or for the current project (which thus needs to be a package) if no positional argument is given to <code>Pkg.test</code>. A package is tested by running its <code>test/runtests.jl</code> file.</p><p>The tests are run by generating a temporary environment with only <code>pkg</code> and its (recursive) dependencies in it. If a manifest exists, the versions in that manifest are used, otherwise a feasible set of packages is resolved and installed.</p><p>During the tests, test-specific dependencies are active, which are given in the project file as e.g.</p><pre><code class="language-none">[extras]
Test = &quot;8dfed614-e22c-5e08-85e1-65c5234f0b40&quot;

[targets]
test = [&quot;Test&quot;]</code></pre><p>Coverage statistics for the packages may be generated by passing <code>coverage=true</code>. The default behavior is to not run coverage.</p><p>The tests are executed in a new process with <code>check-bounds=yes</code> and by default <code>startup-file=no</code>. If using the startup file (<code>~/.julia/config/startup.jl</code>) is desired, start julia with <code>--startup-file=yes</code>. Inlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with <code>--inline=no</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L141-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.build" href="#Pkg.build"><code>Pkg.build</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.build(; verbose = false)
Pkg.build(pkg::Union{String, Vector{String}}; verbose = false)
Pkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false)</code></pre><p>Run the build script in <code>deps/build.jl</code> for <code>pkg</code> and all of its dependencies in depth-first recursive order. If no argument is given to <code>build</code>, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time. <code>verbose = true</code> prints the build output to <code>stdout</code>/<code>stderr</code> instead of redirecting to the <code>build.log</code> file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L185-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.pin" href="#Pkg.pin"><code>Pkg.pin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.pin(pkg::Union{String, Vector{String}})
Pkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>Pin a package to the current version (or the one given in the <code>PackageSpec</code>) or to a certain git revision. A pinned package is never updated.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.pin(&quot;Example&quot;)
Pkg.pin(PackageSpec(name=&quot;Example&quot;, version=&quot;0.3.1&quot;))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L204-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.free" href="#Pkg.free"><code>Pkg.free</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.free(pkg::Union{String, Vector{String}})
Pkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}})</code></pre><p>If <code>pkg</code> is pinned, remove the pin. If <code>pkg</code> is tracking a path, e.g. after <a href="#Pkg.develop"><code>Pkg.develop</code></a>, go back to tracking registered versions.</p><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.free(&quot;Package&quot;)
Pkg.free(PackageSpec(&quot;Package&quot;))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L219-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.instantiate" href="#Pkg.instantiate"><code>Pkg.instantiate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.instantiate()</code></pre><p>If a <code>Manifest.toml</code> file exists in the current project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the <code>Project.toml</code> files and install them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L267-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.resolve" href="#Pkg.resolve"><code>Pkg.resolve</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.resolve()</code></pre><p>Update the current manifest with potential changes to the dependency graph from packages that are tracking a path.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L277-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.gc" href="#Pkg.gc"><code>Pkg.gc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.gc()</code></pre><p>Garbage collect packages that are no longer reachable from any project. Only packages that are tracked by version are deleted, so no packages that might contain local changes are touched.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L175-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.status" href="#Pkg.status"><code>Pkg.status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.status([pkgs...]; mode::PackageMode=PKGMODE_PROJECT, diff::Bool=false)</code></pre><p>Print out the status of the project/manifest. If <code>mode</code> is <code>PKGMODE_PROJECT</code>, print out status only about the packages that are in the project (explicitly added). If <code>mode</code> is <code>PKGMODE_MANIFEST</code>, print status also about those in the manifest (recursive dependencies). If there are any packages listed as arguments, the output will be limited to those packages. Setting <code>diff=true</code> will, if the environment is in a git repository, limit the output to the difference as compared to the last git commit.</p><div class="admonition compat"><div class="admonition-title">Julia 1.1</div><div class="admonition-text"><p><code>Pkg.status</code> with package arguments requires at least Julia 1.1.</p></div></div><div class="admonition compat"><div class="admonition-title">Julia 1.3</div><div class="admonition-text"><p>The <code>diff</code> keyword argument requires Julia 1.3. In earlier versions <code>diff=true</code> is the default for environments in git repositories.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L285-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.precompile" href="#Pkg.precompile"><code>Pkg.precompile</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.precompile()</code></pre><p>Precompile all the dependencies of the project.</p><div class="admonition compat"><div class="admonition-title">Julia 1.3</div><div class="admonition-text"><p>This function requires at least Julia 1.3. On earlier versions you can use <code>Pkg.API.precompile()</code> or the <code>precompile</code> Pkg REPL command.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.precompile()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L100-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.setprotocol!" href="#Pkg.setprotocol!"><code>Pkg.setprotocol!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setprotocol!(;
    domain::AbstractString = &quot;github.com&quot;,
    protocol::Union{Nothing, AbstractString}=nothing
)</code></pre><p>Set the protocol used to access hosted packages when <code>add</code>ing a url or <code>develop</code>ing a package. Defaults to delegating the choice to the package developer (<code>protocol == nothing</code>). Other choices for <code>protocol</code> are <code>&quot;https&quot;</code> or <code>&quot;git&quot;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Pkg.setprotocol!(domain = &quot;github.com&quot;, protocol = &quot;ssh&quot;)

julia&gt; Pkg.setprotocol!(domain = &quot;gitlab.mycompany.com&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L369-L385">source</a></section><h2><a class="nav-anchor" id="Registry-API-Reference-1" href="#Registry-API-Reference-1">Registry API Reference</a></h2><div class="admonition compat"><div class="admonition-title">Julia 1.1</div><div class="admonition-text"><p>Pkg&#39;s registry handling requires at least Julia 1.1.</p></div></div><p>The function API for registries uses <a href="#Pkg.RegistrySpec"><code>RegistrySpec</code></a>s, similar to <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.RegistrySpec" href="#Pkg.RegistrySpec"><code>Pkg.RegistrySpec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RegistrySpec(name::String)
RegistrySpec(; name, url, path)</code></pre><p>A <code>RegistrySpec</code> is a representation of a registry with various metadata, much like <a href="#Pkg.PackageSpec"><code>PackageSpec</code></a>.</p><p>Most registry functions in Pkg take a <code>Vector</code> of <code>RegistrySpec</code> and do the operation on all the registries in the vector.</p><div class="admonition compat"><div class="admonition-title">Julia 1.1</div><div class="admonition-text"><p>Pkg&#39;s registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><p>Below is a comparison between the REPL version and the API version:</p><table><tr><th style="text-align: left"><code>REPL</code></th><th style="text-align: left"><code>API</code></th></tr><tr><td style="text-align: left"><code>Registry</code></td><td style="text-align: left"><code>RegistrySpec(&quot;Registry&quot;)</code></td></tr><tr><td style="text-align: left"><code>Registry=a67d...</code></td><td style="text-align: left"><code>RegistrySpec(name=&quot;Registry&quot;, uuid=&quot;a67d...&quot;)</code></td></tr><tr><td style="text-align: left"><code>local/path</code></td><td style="text-align: left"><code>RegistrySpec(path=&quot;local/path&quot;)</code></td></tr><tr><td style="text-align: left"><code>www.myregistry.com</code></td><td style="text-align: left"><code>RegistrySpec(url=&quot;www.myregistry.com&quot;)</code></td></tr></table></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Pkg.jl#L388-L411">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.Registry.add" href="#Pkg.Registry.add"><code>Pkg.Registry.add</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.Registry.add(url::String)
Pkg.Registry.add(registry::RegistrySpec)</code></pre><p>Add new package registries.</p><div class="admonition compat"><div class="admonition-title">Julia 1.1</div><div class="admonition-text"><p>Pkg&#39;s registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.Registry.add(&quot;General&quot;)
Pkg.Registry.add(RegistrySpec(uuid = &quot;23338594-aafe-5451-b93e-139f81909106&quot;))
Pkg.Registry.add(RegistrySpec(url = &quot;https://github.com/JuliaRegistries/General.git&quot;))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Registry.jl#L8-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.Registry.rm" href="#Pkg.Registry.rm"><code>Pkg.Registry.rm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.Registry.rm(registry::String)
Pkg.Registry.rm(registry::RegistrySpec)</code></pre><p>Remove registries.</p><div class="admonition compat"><div class="admonition-title">Julia 1.1</div><div class="admonition-text"><p>Pkg&#39;s registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.Registry.rm(&quot;General&quot;)
Pkg.Registry.rm(RegistrySpec(uuid = &quot;23338594-aafe-5451-b93e-139f81909106&quot;))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Registry.jl#L31-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.Registry.update" href="#Pkg.Registry.update"><code>Pkg.Registry.update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.Registry.update()
Pkg.Registry.update(registry::RegistrySpec)
Pkg.Registry.update(registry::Vector{RegistrySpec})</code></pre><p>Update registries. If no registries are given, update all available registries.</p><div class="admonition compat"><div class="admonition-title">Julia 1.1</div><div class="admonition-text"><p>Pkg&#39;s registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.Registry.update()
Pkg.Registry.update(&quot;General&quot;)
Pkg.Registry.update(RegistrySpec(uuid = &quot;23338594-aafe-5451-b93e-139f81909106&quot;))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Registry.jl#L52-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pkg.Registry.status" href="#Pkg.Registry.status"><code>Pkg.Registry.status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Pkg.Registry.status()</code></pre><p>Display information about available registries.</p><div class="admonition compat"><div class="admonition-title">Julia 1.1</div><div class="admonition-text"><p>Pkg&#39;s registry handling requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia">Pkg.Registry.status()</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/Pkg.jl/blob/56403e1065ab868d828bb8370f71e18adca6c953/src/Registry.jl#L78-L90">source</a></section><footer><hr/><a class="previous" href="../repl/"><span class="direction">Previous</span><span class="title"><strong>10.</strong> REPL Mode Reference</span></a></footer></article></body></html>
