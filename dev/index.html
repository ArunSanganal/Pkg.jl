<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1. Introduction · Pkg.jl</title><link rel="canonical" href="https://julialang.github.io/Pkg.jl/v1/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href><img class="logo" src="assets/logo.png" alt="Pkg.jl logo"/></a><h1>Pkg.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href><strong>1.</strong> Introduction</a><ul class="internal"><li><a class="toctext" href="#Background-and-Design-1">Background and Design</a></li></ul></li><li><a class="toctext" href="getting-started/"><strong>2.</strong> Getting Started</a></li><li><a class="toctext" href="managing-packages/"><strong>3.</strong> Managing Packages</a></li><li><a class="toctext" href="environments/"><strong>4.</strong> Working with Environments</a></li><li><a class="toctext" href="creating-packages/"><strong>5.</strong> Creating Packages</a></li><li><a class="toctext" href="compatibility/"><strong>6.</strong> Compatibility</a></li><li><a class="toctext" href="registries/"><strong>7.</strong> Registries</a></li><li><a class="toctext" href="artifacts/"><strong>8.</strong> Artifacts</a></li><li><a class="toctext" href="glossary/"><strong>9.</strong> Glossary</a></li><li><a class="toctext" href="toml-files/"><strong>10.</strong> <code>Project.toml</code> and <code>Manifest.toml</code></a></li><li><a class="toctext" href="repl/"><strong>11.</strong> REPL Mode Reference</a></li><li><a class="toctext" href="api/"><strong>12.</strong> API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href><strong>1.</strong> Introduction</a></li></ul><a class="edit-page" href="https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>1. Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="**1.**-Introduction-1" href="#**1.**-Introduction-1"><strong>1.</strong> Introduction</a></h1><p>Welcome to the documentation for Pkg, Julia&#39;s package manager. The documentation covers many things, for example managing package installations, developing packages, working with package registries and more.</p><p>Throughout the manual the REPL interface to Pkg is used in the examples. There is also a functional API interface, which is preferred when not working interactively. This API is documented in the <a href="api/#API-Reference-1">API Reference</a> section.</p><h2><a class="nav-anchor" id="Background-and-Design-1" href="#Background-and-Design-1">Background and Design</a></h2><p>Pkg is a complete rewrite of Julia&#39;s old package manager<a href="#footnote-1">[1]</a> and was released together with Julia v1.0. Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around “environments”: independent sets of packages that can be local to an individual project or shared and selected by name. The exact set of packages and versions in an environment is captured in a <em>manifest file</em> which can be checked into a project repository and tracked in version control, significantly improving reproducibility of projects. If you’ve ever tried to run code you haven’t used in a while only to find that you can’t get anything to work because you’ve updated or uninstalled some of the packages your project was using, you’ll understand the motivation for this approach. In Pkg, since each project maintains its own independent set of package versions, you’ll never have this problem again. Moreover, if you check out a project on a new system, you can simply materialize the environment described by its manifest file and immediately be up and running with a known-good set of dependencies.</p><p>Since environments are managed and updated independently from each other, “dependency hell” is significantly alleviated in Pkg. If you want to use the latest and greatest version of some package in a new project but you’re stuck on an older version in a different project, that’s no problem – since they have separate environments they can just use different versions, which are both installed at the same time in different locations on your system. The location of each package version is canonical, so when environments use the same versions of packages, they can share installations, avoiding unnecessary duplication of the package. Old package versions that are no longer used by any environments are periodically “garbage collected” by the package manager.</p><p>Pkg’s approach to local environments may be familiar to people who have used Python’s <code>virtualenv</code> or Ruby’s <code>bundler</code>. In Julia, instead of hacking the language’s code loading mechanisms to support environments, we have the benefit that Julia natively understands them. In addition, Julia environments are “stackable”: you can overlay one environment with another and thereby have access to additional packages outside of the primary environment. This makes it easy to work on a project, which provides the primary environment, while still having access to all your usual dev tools like profilers, debuggers, and so on, just by having an environment including these dev tools later in the load path.</p><p>Last but not least, Pkg is designed to support federated package registries. This means that it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that’s critical to your company’s product, you can tag a private version of it in your company’s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you&#39;ll be back on an official release again.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Often denoted <code>Pkg2</code>, now archived as <code>OldPkg</code> at   <a href="https://github.com/JuliaAttic/OldPkg.jl"><code>github.com/JuliaAttic/OldPkg.jl</code></a>.</p></div><footer><hr/><a class="next" href="getting-started/"><span class="direction">Next</span><span class="title"><strong>2.</strong> Getting Started</span></a></footer></article></body></html>
