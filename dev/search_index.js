var documenterSearchIndex = {"docs":
[{"location":"basedocs/","page":"Pkg","title":"Pkg","text":"EditURL = \"https://github.com/JuliaLang/Pkg.jl/blob/master/docs/src/basedocs.md\"","category":"page"},{"location":"basedocs/#Pkg","page":"Pkg","title":"Pkg","text":"","category":"section"},{"location":"basedocs/","page":"Pkg","title":"Pkg","text":"Pkg is Julia's builtin package manager, and handles operations such as installing, updating and removing packages.","category":"page"},{"location":"basedocs/","page":"Pkg","title":"Pkg","text":"note: Note\nWhat follows is a very brief introduction to Pkg. For more information on Project.toml files, Manifest.toml files, package version compatibility ([compat]), environments, registries, etc., it is highly recommended to read the full manual, which is available here: https://pkgdocs.julialang.org.","category":"page"},{"location":"basedocs/","page":"Pkg","title":"Pkg","text":"import Markdown\nfile = joinpath(Sys.STDLIB, \"Pkg\", \"docs\", \"src\", \"getting-started.md\")\nstr = read(file, String)\nstr = replace(str, r\"^#.*$\"m => \"\")\nstr = replace(str, \"[API Reference](@ref)\" =>\n          \"[API Reference](https://pkgdocs.julialang.org/v1/api/)\")\nMarkdown.parse(str)","category":"page"},{"location":"artifacts/#Artifacts","page":"8. Artifacts","title":"8. Artifacts","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"compat: Julia 1.3\nPkg's artifacts functionality requires at least Julia 1.3.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Pkg can install and manage containers of data that are not Julia packages.  These containers can contain platform-specific binaries, datasets, text, or any other kind of data that would be convenient to place within an immutable, life-cycled datastore. These containers, (called \"Artifacts\") can be created locally, hosted anywhere, and automatically downloaded and unpacked upon installation of your Julia package. This mechanism is also used to provide the binary dependencies for packages built with BinaryBuilder.jl.","category":"page"},{"location":"artifacts/#Basic-Usage","page":"8. Artifacts","title":"Basic Usage","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Pkg artifacts are declared in an Artifacts.toml file, which can be placed in your current directory or in the root of your package. Currently, Pkg supports downloading of tarfiles (which can be compressed) from a URL. Following is a minimal Artifacts.toml file which will permit the downloading of a socrates.tar.gz file from github.com. In this example, a single artifact, given the name socrates, is defined.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"# a simple Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"If this Artifacts.toml file is placed in your current directory, then socrates.tar.gz can be downloaded, unpacked and used with artifact\"socrates\". Since this tarball contains a folder bin, and a text file named socrates within that folder, we could access the content of that file as follows.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using Pkg.Artifacts\n\nrootpath = artifact\"socrates\"\nopen(joinpath(rootpath, \"bin\", \"socrates\")) do file\n    println(read(file, String))\nend","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"If you have an existing tarball that is accessible via a url, it could also be be accessed in this manner. To create the Artifacts.toml you must compute two hashes: the sha256 hash of the download file, and the git-tree-sha1 of the unpacked content. These can be computed as follows.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using Tar, Inflate, SHA\n\nfilename = \"socrates.tar.gz\"\nprintln(\"sha256: \", bytes2hex(open(sha256, filename)))\nprintln(\"git-tree-sha1: \", Tar.tree_hash(IOBuffer(inflate_gzip(filename))))","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"To access this artifact from within a package you create, place the Artifacts.toml at the root of your package, adjacent to Project.toml. Then, make sure to add Pkg in your deps and set julia = \"1.3\" or higher in your compat section.","category":"page"},{"location":"artifacts/#Artifacts.toml-files","page":"8. Artifacts","title":"Artifacts.toml files","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Pkg provides an API for working with artifacts, as well as a TOML file format for recording artifact usage in your packages, and to automate downloading of artifacts at package install time. Artifacts can always be referred to by content hash, but are typically accessed by a name that is bound to a content hash in an Artifacts.toml file that lives in a project's source tree.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"note: Note\nIt is possible to use the alternate name JuliaArtifacts.toml, similar to how it is possible to use JuliaProject.toml and JuliaManifest.toml instead of Project.toml and Manifest.toml, respectively.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"An example Artifacts.toml file is shown here:","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"# Example Artifacts.toml file\n[socrates]\ngit-tree-sha1 = \"43563e7631a7eafae1f9f8d9d332e3de44ad7239\"\nlazy = true\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.gz\"\n    sha256 = \"e65d2f13f2085f2c279830e863292312a72930fee5ba3c792b14c33ce5c5cc58\"\n\n    [[socrates.download]]\n    url = \"https://github.com/staticfloat/small_bin/raw/master/socrates.tar.bz2\"\n    sha256 = \"13fc17b97be41763b02cbb80e9d048302cec3bd3d446c2ed6e8210bddcd3ac76\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"4bdf4556050cb55b67b211d4e78009aaec378cbc\"\nlibc = \"musl\"\nos = \"linux\"\n\n    [[c_simple.download]]\n    sha256 = \"411d6befd49942826ea1e59041bddf7dbb72fb871bb03165bf4e164b13ab5130\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-linux-musl.tar.gz\"\n\n[[c_simple]]\narch = \"x86_64\"\ngit-tree-sha1 = \"51264dbc770cd38aeb15f93536c29dc38c727e4c\"\nos = \"macos\"\n\n    [[c_simple.download]]\n    sha256 = \"6c17d9e1dc95ba86ec7462637824afe7a25b8509cc51453f0eb86eda03ed4dc3\"\n    url = \"https://github.com/JuliaBinaryWrappers/c_simple_jll.jl/releases/download/c_simple+v1.2.3+0/c_simple.v1.2.3.x86_64-apple-darwin14.tar.gz\"\n\n[processed_output]\ngit-tree-sha1 = \"1c223e66f1a8e0fae1f9fcb9d3f2e3ce48a82200\"","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"This Artifacts.toml binds three artifacts; one named socrates, one named c_simple and one named processed_output. The single required piece of information for an artifact is its git-tree-sha1. Because artifacts are addressed only by their content hash, the purpose of an Artifacts.toml file is to provide metadata about these artifacts, such as binding a human-readable name to a content hash, providing information about where an artifact may be downloaded from, or even binding a single name to multiple hashes, keyed by platform-specific constraints such as operating system or libgfortran version.","category":"page"},{"location":"artifacts/#Artifact-types-and-properties","page":"8. Artifacts","title":"Artifact types and properties","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"In the above example, the socrates artifact showcases a platform-independent artifact with multiple download locations. When downloading and installing the socrates artifact, URLs will be attempted in-order until one succeeds. The socrates artifact is marked as lazy, which means that it will not be automatically downloaded when the containing package is installed, but rather will be downloaded on-demand when the package first attempts to use it.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"The c_simple artifact showcases a platform-dependent artifact, where each entry in the c_simple array contains keys that help the calling package choose the appropriate download based on the particulars of the host machine. Note that each artifact contains both a git-tree-sha1 and a sha256 for each download entry.  This is to ensure that the downloaded tarball is secure before attempting to unpack it, as well as enforcing that all tarballs must expand to the same overall tree hash.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"The processed_output artifact contains no download stanza, and so cannot be installed. An artifact such as this would be the result of code that was previously run, generating a new artifact and binding the resultant hash to a name within this project.","category":"page"},{"location":"artifacts/#Using-Artifacts","page":"8. Artifacts","title":"Using Artifacts","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Artifacts can be manipulated using convenient APIs exposed from the Pkg.Artifacts namespace. As a motivating example, let us imagine that we are writing a package that needs to load the Iris machine learning dataset. While we could just download the dataset during a build step into the package directory, and many packages currently do precisely this, that has some significant drawbacks:","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"First, it modifies the package directory, making package installation stateful, which we want to avoid. In the future, we would like to reach the point where packages can be installed completely read-only, instead of being able to modify themselves after installation.\nSecond, the downloaded data is not shared across different versions of our package. If we have three different versions of the package installed for use by various projects, then we need three different copies of the data, even if it hasn't changed between those versions. Moreover, each time we upgrade or downgrade the package, unless we do something clever (and probably brittle), we have to download the data again.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"With artifacts, we will instead check to see if our iris artifact already exists on-disk and only if it doesn't will we download and install it, after which we can bind the result into our Artifacts.toml file:","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using Pkg.Artifacts\n\n# This is the path to the Artifacts.toml we will manipulate\nartifact_toml = joinpath(@__DIR__, \"Artifacts.toml\")\n\n# Query the `Artifacts.toml` file for the hash bound to the name \"iris\"\n# (returns `nothing` if no such binding exists)\niris_hash = artifact_hash(\"iris\", artifact_toml)\n\n# If the name was not bound, or the hash it was bound to does not exist, create it!\nif iris_hash == nothing || !artifact_exists(iris_hash)\n    # create_artifact() returns the content-hash of the artifact directory once we're finished creating it\n    iris_hash = create_artifact() do artifact_dir\n        # We create the artifact by simply downloading a few files into the new artifact directory\n        iris_url_base = \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris\"\n        download(\"$(iris_url_base)/iris.data\", joinpath(artifact_dir, \"iris.csv\"))\n        download(\"$(iris_url_base)/bezdekIris.data\", joinpath(artifact_dir, \"bezdekIris.csv\"))\n        download(\"$(iris_url_base)/iris.names\", joinpath(artifact_dir, \"iris.names\"))\n    end\n\n    # Now bind that hash within our `Artifacts.toml`.  `force = true` means that if it already exists,\n    # just overwrite with the new content-hash.  Unless the source files change, we do not expect\n    # the content hash to change, so this should not cause unnecessary version control churn.\n    bind_artifact!(artifact_toml, \"iris\", iris_hash)\nend\n\n# Get the path of the iris dataset, either newly created or previously generated.\n# this should be something like `~/.julia/artifacts/dbd04e28be047a54fbe9bf67e934be5b5e0d357a`\niris_dataset_path = artifact_path(iris_hash)","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"For the specific use case of using artifacts that were previously bound, we have the shorthand notation artifact\"name\" which will automatically search for the Artifacts.toml file contained within the current package, look up the given artifact by name, install it if it is not yet installed, then return the path to that given artifact. An example of this shorthand notation is given below:","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using Pkg.Artifacts\n\n# For this to work, an `Artifacts.toml` file must be in the current working directory\n# (or in the root of the current package) and must define a mapping for the \"iris\"\n# artifact.  If it does not exist on-disk, it will be downloaded.\niris_dataset_path = artifact\"iris\"","category":"page"},{"location":"artifacts/#The-Pkg.Artifacts-API","page":"8. Artifacts","title":"The Pkg.Artifacts API","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"The Artifacts API is broken up into three levels: hash-aware functions, name-aware functions and utility functions.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Hash-aware functions deal with content-hashes and essentially nothing else. These methods allow you to query whether an artifact exists, what its path is, to verify that an artifact satisfies its content hash on-disk, etc.  Hash-aware functions include: artifact_exists(), artifact_path(), remove_artifact(), verify_artifact() and archive_artifact().  Note that in general you should not use remove_artifact() and should instead use Pkg.gc() to cleanup artifact installations.\nName-aware functions deal with bound names within an Artifacts.toml file, and as such, typically require both a path to an Artifacts.toml file as well as the artifact name.  Name-aware functions include: artifact_meta(), artifact_hash(), bind_artifact!(), unbind_artifact!(), download_artifact() and ensure_artifact_installed().\nUtility functions deal with miscellaneous aspects of artifact life, such as create_artifact(), ensure_all_artifacts_installed(), and even the @artifact_str string macro.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"For a full listing of docstrings and methods, see the Artifacts Reference section.","category":"page"},{"location":"artifacts/#Overriding-artifact-locations","page":"8. Artifacts","title":"Overriding artifact locations","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"It is occasionally necessary to be able to override the location and content of an artifact. A common use case is a computing environment where certain versions of a binary dependency must be used, regardless of what version of this dependency a package was published with. While a typical Julia configuration would download, unpack and link against a generic library, a system administrator may wish to disable this and instead use a library already installed on the local machine. To enable this, Pkg supports a per-depot Overrides.toml file placed within the artifacts depot directory (e.g. ~/.julia/artifacts/Overrides.toml for the default user depot) that can override the location of an artifact either by content-hash or by package UUID and bound artifact name. Additionally, the destination location can be either an absolute path, or a replacement artifact content hash. This allows sysadmins to create their own artifacts which they can then use by overriding other packages to use the new artifact.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"# Override single hash to absolute path\n78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/replacement\"\n\n# Override single hash to new artifact content-hash\n683942669b4639019be7631caa28c38f3e1924fe = \"d826e316b6c0d29d9ad0875af6ca63bf67ed38c3\"\n\n# Override package bindings by specifying the package UUID and bound artifact name\n# For demonstration purposes we assume this package is called `Foo`\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"/path/to/libfoo\"\nlibbar = \"683942669b4639019be7631caa28c38f3e1924fe\"","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Due to the layered nature of Pkg depots, multiple Overrides.toml files may be in effect at once. This allows the \"inner\" Overrides.toml files to override the overrides placed within the \"outer\" Overrides.toml files. To remove an override and re-enable default location logic for an artifact, insert an entry mapping to the empty string:","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"78f35e74ff113f02274ce60dab6e92b4546ef806 = \"/path/to/new/replacement\"\n683942669b4639019be7631caa28c38f3e1924fe = \"\"\n\n[d57dbccd-ca19-4d82-b9b8-9d660942965b]\nlibfoo = \"\"","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"If the two Overrides.toml snippets as given above are layered on top of eachother, the end result will be mapping the content-hash 78f35e74ff113f02274ce60dab6e92b4546ef806 to \"/path/to/new/replacement\", and mapping Foo.libbar to the artifact identified by the content-hash 683942669b4639019be7631caa28c38f3e1924fe. Note that while that hash was previously overridden, it is no longer, and therefore Foo.libbar will look directly at locations such as ~/.julia/artifacts/683942669b4639019be7631caa28c38f3e1924fe.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"Most methods that are affected by overrides have the ability to ignore overrides by setting honor_overrides=false as a keyword argument within them. For UUID/name based overrides to work, Artifacts.toml files must be loaded with the knowledge of the UUID of the loading package. This is deduced automatically by the artifacts\"\" string macro, however if you are for some reason manually using the Pkg.Artifacts API within your package and you wish to honor overrides, you must provide the package UUID to API calls like artifact_meta() and ensure_artifact_installed() via the pkg_uuid keyword argument.","category":"page"},{"location":"artifacts/#Extending-Platform-Selection","page":"8. Artifacts","title":"Extending Platform Selection","text":"","category":"section"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"compat: Julia 1.6\nPkg's extended platform selection requires at least Julia 1.6, and is considered experimental.","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"New in Julia 1.6, Platform objects can have extended attributes applied to them, allowing artifacts to be tagged with things such as CUDA driver version compatibility, microarchitectural compatibility, julia version compatibility and more! Note that this feature is considered experimental and may change in the future. If you as a package developer find yourself needing this feature, please get in contact with us so it can evolve for the benefit of the whole ecosystem. In order to support artifact selection at Pkg.add() time, Pkg will run the specially-named file <project_root>/.pkg/select_artifacts.jl, passing the current platform triplet as the first arugment. This artifact selection script should print a TOML-serialized dictionary representing the artifacts that this package needs according to the given platform, and performing any inspection of the system as necessary to auto-detect platform capabilities, if they are not explicitly provided by the given platform triplet. The format of the dictionary should match that returned from Artifacts.select_downloadable_artifacts(), and indeed most packages should simply call that function with an augmented Platform object. An example artifact selection hook definition might look like the following, split across two files:","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"# .pkg/platform_augmentation.jl\nusing Libdl, Base.BinaryPlatforms\nfunction augment_platform!(p::Platform)\n    # If this platform object already has a `cuda` tag set, don't augment\n    if haskey(p, \"cuda\")\n        return p\n    end\n\n    # Open libcuda explicitly, so it gets `dlclose()`'ed after we're done\n    dlopen(\"libcuda\") do lib\n        # find symbol to ask for driver version; if we can't find it, just silently continue\n        cuDriverGetVersion = dlsym(lib, \"cuDriverGetVersion\"; throw_error=false)\n        if cuDriverGetVersion !== nothing\n            # Interrogate CUDA driver for driver version:\n            driverVersion = Ref{Cint}()\n            ccall(cuDriverGetVersion, UInt32, (Ptr{Cint},), driverVersion)\n\n            # Store only the major version\n            p[\"cuda\"] = div(driverVersion, 1000)\n        end\n    end\n\n    # Return possibly-altered `Platform` object\n    return p\nend","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"using TOML, Artifacts, Base.BinaryPlatforms\ninclude(\"./platform_augmentation.jl\")\nartifacts_toml = joinpath(dirname(@__DIR__), \"Artifacts.toml\")\n\n# Get \"target triplet\" from ARGS, if given (defaulting to the host triplet otherwise)\ntarget_triplet = get(ARGS, 1, Base.BinaryPlatforms.host_triplet())\n\n# Augment this platform object with any special tags we require\nplatform = augment_platform!(HostPlatform(parse(Platform, target_triplet)))\n\n# Select all downloadable artifacts that match that platform\nartifacts = select_downloadable_artifacts(artifacts_toml; platform)\n\n# Output the result to `stdout` as a TOML dictionary\nTOML.print(stdout, artifacts)","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"In this hook definition, our platform augmentation routine opens a system library (libcuda), searches it for a symbol to give us the CUDA driver version, then embeds the major version of that version number into the cuda property of the Platform object we are augmenting. While it is not critical for this code to actually attempt to close the loaded library (as it will most likely be opened again by the CUDA package immediately after the package operations are completed) it is best practice to make hooks as lightweight and transparent as possible, as they may be used by other Pkg utilities in the future. In your own package, you should also use augmented platform objects when using the @artifact_str macro, as follows:","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"include(\"../.pkg/platform_augmentation.jl\")\n\nfunction __init__()\n    p = augment_platform!(HostPlatform())\n    global my_artifact_dir = @artifact_str(\"MyArtifact\", p)\nend","category":"page"},{"location":"artifacts/","page":"8. Artifacts","title":"8. Artifacts","text":"This ensures that the same artifact is used by your code as Pkg attempted to install.","category":"page"},{"location":"toml-files/#Project-and-Manifest","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Two files that are central to Pkg are Project.toml and Manifest.toml. Project.toml and Manifest.toml are written in TOML (hence the .toml extension) and include information about dependencies, versions, package names, UUIDs etc.","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"note: Note\nThe Project.toml and Manifest.toml files are not only used by the package manager; they are also used by Julia's code loading, and determine e.g. what using Example should do. For more details see the section about Code Loading in the Julia manual.","category":"page"},{"location":"toml-files/#Project.toml","page":"10. Project.toml and Manifest.toml","title":"Project.toml","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The project file describes the project on a high level, for example the package/project dependencies and compatibility constraints are listed in the project file. The file entries are described below.","category":"page"},{"location":"toml-files/#The-authors-field","page":"10. Project.toml and Manifest.toml","title":"The authors field","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"For a package, the optional authors field is a list of strings describing the package authors, in the form NAME <EMAIL>. For example:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"authors = [\"Some One <someone@email.com>\",\n           \"Foo Bar <foo@bar.com>\"]","category":"page"},{"location":"toml-files/#The-name-field","page":"10. Project.toml and Manifest.toml","title":"The name field","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The name of the package/project is determined by the name field, for example:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"name = \"Example\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The name must be a valid identifier (a sequence of Unicode characters that does not start with a number and is neither true nor false). For packages it is recommended to follow the package naming guidelines. The name field is mandatory for packages.","category":"page"},{"location":"toml-files/#The-uuid-field","page":"10. Project.toml and Manifest.toml","title":"The uuid field","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"uuid is a string with a universally unique identifier for the package/project, for example:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The uuid field is mandatory for packages.","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"note: Note\nIt is recommended that UUIDs.uuid4() is used to generate random UUIDs.","category":"page"},{"location":"toml-files/#The-version-field","page":"10. Project.toml and Manifest.toml","title":"The version field","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"version is a string with the version number for the package/project. It should consist of three numbers, major version, minor version and patch number, separated with a ., for example:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"version = \"1.2.5\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Julia uses Semantic Versioning (SemVer) and the version field should follow SemVer. The basic rules are:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Before 1.0.0, anything goes, but when you make breaking changes the minor version should be incremented.\nAfter 1.0.0 only make breaking changes when incrementing the major version.\nAfter 1.0.0 no new public API should be added without incrementing the minor version. This includes, in particular, new types, functions, methods and method overloads, from Base or other packages.","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"See also the section on Compatibility.","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Note that Pkg.jl deviates from the SemVer specification when it comes to versions pre-1.0.0. See the section on pre-1.0 behavior for more details.","category":"page"},{"location":"toml-files/#The-[deps]-section","page":"10. Project.toml and Manifest.toml","title":"The [deps] section","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"All dependencies of the package/project are listed in the [deps] section. Each dependency is listed as a name-uuid pair, for example:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Typically it is not needed to manually add entries to the [deps] section; this is instead handled by Pkg operations such as add.","category":"page"},{"location":"toml-files/#The-[compat]-section","page":"10. Project.toml and Manifest.toml","title":"The [compat] section","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Compatibility constraints for the dependencies listed under [deps] can be listed in the [compat] section. Example:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\n[compat]\nExample = \"1.2\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The Compatibility section describes the different possible compatibility constraints in detail. It is also possible to list constraints on julia itself, although julia is not listed as a dependency in the [deps] section:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[compat]\njulia = \"1.1\"","category":"page"},{"location":"toml-files/#Manifest.toml","page":"10. Project.toml and Manifest.toml","title":"Manifest.toml","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The manifest file is an absolute record of the state of the packages in the environment. It includes exact information about (direct and indirect) dependencies of the project. Given a Project.toml + Manifest.toml pair, it is possible to instantiate the exact same package environment, which is very useful for reproducibility. For the details, see Pkg.instantiate.","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"note: Note\nThe Manifest.toml file is generated and maintained by Pkg and, in general, this file should never be modified manually.","category":"page"},{"location":"toml-files/#Manifest.toml-entries","page":"10. Project.toml and Manifest.toml","title":"Manifest.toml entries","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Each dependency has its own section in the manifest file, and its content varies depending on how the dependency was added to the environment. Every dependency section includes a combination of the following entries:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"uuid: the UUID for the dependency, for example uuid = \"7876af07-990d-54b4-ab0e-23690620f79a\".\ndeps: a vector listing the dependencies of the dependency, for example deps = [\"Example\", \"JSON\"].\nversion: a version number, for example version = \"1.2.6\".\npath: a file path to the source code, for example path = /home/user/Example.\nrepo-url: a URL to the repository where the source code was found, for example repo-url = \"https://github.com/JuliaLang/Example.jl.git\".\nrepo-rev: a git revision, for example a branch repo-rev = \"master\" or a commit repo-rev = \"66607a62a83cb07ab18c0b35c038fcd62987c9b1\".\ngit-tree-sha1: a content hash of the source tree, for example git-tree-sha1 = \"ca3820cc4e66f473467d912c4b2b3ae5dc968444\".","category":"page"},{"location":"toml-files/#Added-package","page":"10. Project.toml and Manifest.toml","title":"Added package","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"When a package is added from a package registry, for example by invoking pkg> add Example or with a specific version pkg> add Example@1.2, the resulting Manifest.toml entry looks like:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.3\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Note, in particular, that no repo-url is present, since that information is included in the registry where this package were found.","category":"page"},{"location":"toml-files/#Added-package-by-branch","page":"10. Project.toml and Manifest.toml","title":"Added package by branch","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The resulting dependency section when adding a package specified by a branch, e.g. pkg> add Example#master or pkg> add https://github.com/JuliaLang/Example.jl.git, looks like:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"master\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Note that both the branch we are tracking (master) and the remote repository url (\"https://github.com/JuliaLang/Example.jl.git\") are stored in the manifest.","category":"page"},{"location":"toml-files/#Added-package-by-commit","page":"10. Project.toml and Manifest.toml","title":"Added package by commit","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The resulting dependency section when adding a package specified by a commit, e.g. pkg> add Example#cf6ba6cc0be0bb5f56840188563579d67048be34, looks like:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\nrepo-rev = \"cf6ba6cc0be0bb5f56840188563579d67048be34\"\nrepo-url = \"https://github.com/JuliaLang/Example.jl.git\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The only difference from tracking a branch is the content of repo-rev.","category":"page"},{"location":"toml-files/#Developed-package","page":"10. Project.toml and Manifest.toml","title":"Developed package","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The resulting dependency section when adding a package with develop, e.g. pkg> develop Example or pkg> develop /path/to/local/folder/Example, looks like:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\npath = \"/home/user/.julia/dev/Example/\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Note that the path to the source code is included, and changes made to that source tree is directly reflected.","category":"page"},{"location":"toml-files/#Pinned-package","page":"10. Project.toml and Manifest.toml","title":"Pinned package","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Pinned packages are also recorded in the manifest file; the resulting dependency section for e.g. pkg> add Example; pin Example looks like:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[Example]]\ndeps = [\"DependencyA\", \"DependencyB\"]\ngit-tree-sha1 = \"54c7a512469a38312a058ec9f429e1db1f074474\"\npinned = true\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"1.2.4\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"The only difference is the addition of the pinned = true entry.","category":"page"},{"location":"toml-files/#Multiple-package-with-the-same-name","page":"10. Project.toml and Manifest.toml","title":"Multiple package with the same name","text":"","category":"section"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"Julia differentiates packages based on UUID, which means that the name alone is not enough to identify a package. It is possible to have multiple packages in the same environment with the same name, but with different UUID. In such a situation the Manifest.toml file looks a bit different. Consider for example the situation where you have added A and B to your environment, and the Project.toml file looks as follows:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[deps]\nA = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\nB = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"If A now depends on B = \"f41f7b98-334e-11e9-1257-49272045fb24\", i.e. another package named B there will be two different B packages in the Manifest.toml file. In this case the full Manifest.toml file, with git-tree-sha1 and version fields removed for clarity, looks like:","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"[[A]]\nuuid = \"ead4f63c-334e-11e9-00e6-e7f0a5f21b60\"\n\n    [A.deps]\n    B = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n\n[[B]]\nuuid = \"f41f7b98-334e-11e9-1257-49272045fb24\"\n[[B]]\nuuid = \"edca9bc6-334e-11e9-3554-9595dbb4349c\"","category":"page"},{"location":"toml-files/","page":"10. Project.toml and Manifest.toml","title":"10. Project.toml and Manifest.toml","text":"There is now an array of the two B packages, and the [deps] section for A has been expanded in order to be explicit about which B package A depends on.","category":"page"},{"location":"compatibility/#Compatibility","page":"6. Compatibility","title":"6. Compatibility","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Compatibility refers to the ability to restrict the versions of the dependencies that your project is compatible with. If the compatibility for a dependency is not given, the project is assumed to be compatible with all versions of that dependency.","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Compatibility for a dependency is entered in the Project.toml file as for example:","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\njulia = \"1.0\"\nExample = \"0.4.3\"","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"After a compatibility entry is put into the project file, up can be used to apply it.","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"The format of the version specifier is described in detail below.","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"info: Info\nThere is currently no way to give compatibility from the Pkg REPL mode so for now, one has to manually edit the project file.","category":"page"},{"location":"compatibility/#Version-specifier-format","page":"6. Compatibility","title":"Version specifier format","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Similar to other package managers, the Julia package manager respects semantic versioning (semver). As an example, a version specifier given as e.g. 1.2.3 is therefore assumed to be compatible with the versions [1.2.3 - 2.0.0) where ) is a non-inclusive upper bound. More specifically, a version specifier is either given as a caret specifier, e.g. ^1.2.3  or as a tilde specifier, e.g. ~1.2.3. Caret specifiers are the default and hence 1.2.3 == ^1.2.3. The difference between a caret and tilde is described in the next section. The union of multiple version specifiers can be formed by comma separating individual version specifiers, e.g.","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nExample = \"1.2, 2\"","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"will result in [1.2.0, 3.0.0).  Note leading zeros are treated differently, e.g. Example = \"0.2, 1\" would only result in [0.2.0-0.3.0, 1.0.0-2.0.0]. See the next section for more information on versions with leading zeros.","category":"page"},{"location":"compatibility/#compat-pre-1.0","page":"6. Compatibility","title":"Behavior of versions with leading zeros (0.0.x and 0.x.y)","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"While the semver specification says that all versions with a major version of 0 (versions before 1.0.0) are incompatible with each other, we have decided to only apply that for when both the major and minor versions are zero. In other words, 0.0.1 and 0.0.2 are considered incompatible. A pre-1.0 version with non-zero minor version (0.a.b with a != 0) is considered compatible with versions with the same minor version and smaller or equal patch versions (0.a.c with c <= b); i.e., the versions 0.2.2 and 0.2.3 are compatible with 0.2.1 and 0.2.0. Versions with a major version of 0 and different minor versions are not considered compatible, so the version 0.3.0 might have breaking changes from 0.2.0. To that end, the [compat] entry:","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nExample = \"0.0.1\"","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"results in a versionbound on Example as [0.0.1, 0.0.2) (which is equivalent to only the version 0.0.1), while the [compat] entry:","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nExample = \"0.2.1\"","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"results in a versionbound on Example as [0.2.1, 0.3.0).","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"In particular, a package may set version = \"0.2.4\" when it has feature additions compared to 0.2.3 as long as it remains backward compatible with 0.2.0.  See also The version field.","category":"page"},{"location":"compatibility/#Caret-specifiers","page":"6. Compatibility","title":"Caret specifiers","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"A caret specifier allows upgrade that would be compatible according to semver. An updated dependency is considered compatible if the new version does not modify the left-most non zero digit in the version specifier.","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Some examples are shown below.","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nPkgA = \"^1.2.3\" # [1.2.3, 2.0.0)\nPkgB = \"^1.2\"   # [1.2.0, 2.0.0)\nPkgC = \"^1\"     # [1.0.0, 2.0.0)\nPkgD = \"^0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"^0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"^0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"^0\"     # [0.0.0, 1.0.0)","category":"page"},{"location":"compatibility/#Tilde-specifiers","page":"6. Compatibility","title":"Tilde specifiers","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"A tilde specifier provides more limited upgrade possibilities. When specifying major, minor and patch versions, or when specifying major and minor versions, only the patch version is allowed to change. If you only specify a major version, then both minor and patch versions are allowed to be upgraded (~1 is thus equivalent to ^1). For example:","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nPkgA = \"~1.2.3\" # [1.2.3, 1.3.0)\nPkgB = \"~1.2\"   # [1.2.0, 1.3.0)\nPkgC = \"~1\"     # [1.0.0, 2.0.0)\nPkgD = \"~0.2.3\" # [0.2.3, 0.3.0)\nPkgE = \"~0.0.3\" # [0.0.3, 0.0.4)\nPkgF = \"~0.0\"   # [0.0.0, 0.1.0)\nPkgG = \"~0\"     # [0.0.0, 1.0.0)","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"For all versions with a major version of 0 the tilde and caret specifiers are equivalent.","category":"page"},{"location":"compatibility/#Equality-specifier","page":"6. Compatibility","title":"Equality specifier","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Equality can be used to specify an exact version:","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nPkgA = \"= 1.2.3\"  # [1.2.3, 1.2.3]","category":"page"},{"location":"compatibility/#Inequality-specifiers","page":"6. Compatibility","title":"Inequality specifiers","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Inequalities can also be used to specify version ranges:","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nPkgB = \">= 1.2.3\" # [1.2.3,  ∞)\nPkgC = \"≥ 1.2.3\"  # [1.2.3,  ∞)\nPkgD = \"< 1.2.3\"  # [0.0.0, 1.2.3) = [0.0.0, 1.2.2]","category":"page"},{"location":"compatibility/#Hyphen-specifiers","page":"6. Compatibility","title":"Hyphen specifiers","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Hyphen syntax can also be used to specify version ranges. Make sure that you have a space on both sides of the hyphen.","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nPkgA = \"1.2.3 - 4.5.6\" # [1.2.3, 4.5.6]\nPkgA = \"0.2.3 - 4.5.6\" # [0.2.3, 4.5.6]","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Any unspecified trailing numbers in the first end-point are considered to be zero:","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nPkgA = \"1.2 - 4.5.6\"   # [1.2.0, 4.5.6]\nPkgA = \"1 - 4.5.6\"     # [1.0.0, 4.5.6]\nPkgA = \"0.2 - 4.5.6\"   # [0.2.0, 4.5.6]\nPkgA = \"0.2 - 0.5.6\"   # [0.2.0, 0.5.6]","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Any unspecified trailing numbers in the second end-point will be considered to be wildcards:","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nPkgA = \"1.2.3 - 4.5\"   # 1.2.3 - 4.5.* = [1.2.3, 4.6.0)\nPkgA = \"1.2.3 - 4\"     # 1.2.3 - 4.*.* = [1.2.3, 5.0.0)\nPkgA = \"1.2 - 4.5\"     # 1.2.0 - 4.5.* = [1.2.0, 4.6.0)\nPkgA = \"1.2 - 4\"       # 1.2.0 - 4.*.* = [1.2.0, 5.0.0)\nPkgA = \"1 - 4.5\"       # 1.0.0 - 4.5.* = [1.0.0, 4.6.0)\nPkgA = \"1 - 4\"         # 1.0.0 - 4.*.* = [1.0.0, 5.0.0)\nPkgA = \"0.2.3 - 4.5\"   # 0.2.3 - 4.5.* = [0.2.3, 4.6.0)\nPkgA = \"0.2.3 - 4\"     # 0.2.3 - 4.*.* = [0.2.3, 5.0.0)\nPkgA = \"0.2 - 4.5\"     # 0.2.0 - 4.5.* = [0.2.0, 4.6.0)\nPkgA = \"0.2 - 4\"       # 0.2.0 - 4.*.* = [0.2.0, 5.0.0)\nPkgA = \"0.2 - 0.5\"     # 0.2.0 - 0.5.* = [0.2.0, 0.6.0)\nPkgA = \"0.2 - 0\"       # 0.2.0 - 0.*.* = [0.2.0, 1.0.0)","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"compat: Julia 1.4\nHyphen specifiers requires at least Julia 1.4, so it is strongly recomended to also add[compat]\njulia = \"1.4\"to the project file when using them.","category":"page"},{"location":"compatibility/#Fixing-conflicts","page":"6. Compatibility","title":"Fixing conflicts","text":"","category":"section"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Version conflicts were introduced previously with an example of a conflict arising in a package D used by two other packages, B and C. Our analysis of the error message revealed that B is using an outdated version of D. To fix it, the first thing to try is to pkg> dev B so that you can modify B and its compatibility requirements. If you open its Project.toml file in an editor, you would probably notice something like","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nD = \"0.1\"","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"Usually the first step is to modify this to something like","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"[compat]\nD = \"0.1, 0.2\"","category":"page"},{"location":"compatibility/","page":"6. Compatibility","title":"6. Compatibility","text":"This indicates that B is compatible with both versions 0.1 and version 0.2; if you pkg> up this would fix the package error. However, there is one major concern you need to address first: perhaps there was an incompatible change in v0.2 of D that breaks B. Before proceeding further, you should update all packages and then run B's tests, scanning the output of pkg> test B to be sure that v0.2 of D is in fact being used. (It is possible that an additional dependency of D pins it to v0.1, and you wouldn't want to be misled into thinking that you had tested B on the newer version.) If the new version was used and the tests still pass, you can assume that B didn't need any further updating to accomodate v0.2 of D; you can safely submit this change as a pull request to B so that a new release is made. If instead an error is thrown, it indicates that B requires more extensive updates to be compatible with the latest version of D; those updates will need to be completed before it becomes possible to use both A and B simultaneously. You can, though, continue to use the independently of one another.","category":"page"},{"location":"getting-started/#**2.**-Getting-Started","page":"2. Getting Started","title":"2. Getting Started","text":"","category":"section"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"What follows is a quick overview of Pkg, Julia's package manager. It should help new users become familiar with basic Pkg features.","category":"page"},{"location":"getting-started/#Basic-Usage","page":"2. Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Pkg comes with a REPL. Enter the Pkg REPL by pressing ] from the Julia REPL. To get back to the Julia REPL, press backspace or ^C.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"note: Note\nThis guide relies on the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the API Reference section of the Pkg documentation.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Upon entering the Pkg REPL, you should see a similar prompt:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg>","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"To add a package, use add:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> add Example","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"note: Note\nSome Pkg output has been omitted in order to keep this guide focused. This will help maintain a good pace and not get bogged down in details. If you require more details, refer to subsequent sections of the Pkg manual.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"We can also specify multiple packages at once:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> add JSON StaticArrays","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"To remove packages, use rm:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> rm JSON StaticArrays","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"So far, we have referred only to registered packages. Pkg also supports working with unregistered packages. To add an unregistered package, specify a URL:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> add https://github.com/JuliaLang/Example.jl","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Use rm to remove this package by name:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> rm Example","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Use update to update an installed package:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> update Example","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"To update all installed packages, use update without any arguments:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> update","category":"page"},{"location":"getting-started/#Getting-Started-with-Environments","page":"2. Getting Started","title":"Getting Started with Environments","text":"","category":"section"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Up to this point, we have covered basic package management: adding, updating and removing packages. This will be familiar if you have used other package managers. Pkg offers significant advantages over traditional package managers by organizing dependencies into environments.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"You may have noticed the (v1.1) in the REPL prompt. This lets us know v1.1 is the active environment. The active environment is the environment that will be modified by Pkg commands such as add, rm and update.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Let's set up a new environment so we may experiment. To set the active environment, use activate:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> activate tutorial\n[ Info: activating new environment at `/tmp/tutorial/Project.toml`.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Pkg lets us know we are creating a new environment and that this environment will be stored in the /tmp/tutorial directory.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Pkg has also updated the REPL prompt in order to reflect the new active environment:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(tutorial) pkg>","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"We can ask for information about the active environment by using status:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(tutorial) pkg> status\n    Status `/tmp/tutorial/Project.toml`\n   (empty environment)","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"/tmp/tutorial/Project.toml is the location of the active environment's project file. A project file is where Pkg stores metadata for an environment. Notice this new environment is empty. Let us add a package and observe:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(tutorial) pkg> add Example\n...\n\n(tutorial) pkg> status\n    Status `/tmp/tutorial/Project.toml`\n  [7876af07] Example v0.5.1","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"We can see tutorial now contains Example as a dependency.","category":"page"},{"location":"getting-started/#Modifying-A-Dependency","page":"2. Getting Started","title":"Modifying A Dependency","text":"","category":"section"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Say we are working on Example and feel it needs new functionality. How can we modify the source code? We can use develop to set up a git clone of the Example package.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(tutorial) pkg> develop --local Example\n...\n\n(tutorial) pkg> status\n    Status `/tmp/tutorial/Project.toml`\n  [7876af07] Example v0.5.1+ [`dev/Example`]","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Notice the feedback has changed. dev/Example refers to the location of the newly created clone. If we look inside the /tmp/tutorial directory, we will notice the following files:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"tutorial\n├── dev\n│   └── Example\n├── Manifest.toml\n└── Project.toml","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Instead of loading a registered version of Example, Julia will load the source code contained in tutorial/dev/Example.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Let's try it out. First we modify the file at tutorial/dev/Example/src/Example.jl and add a simple function:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"plusone(x::Int) = x + 1","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Now we can go back to the Julia REPL and load the package:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"julia> import Example","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"warning: Warning\nA package can only be loaded once per Julia session. If you have run import Example in the current Julia session, you will have to restart Julia and rerun activate tutorial in the Pkg REPL. Revise.jl can make this process significantly more pleasant, but setting it up is beyond the scope of this guide.","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Julia should load our new code. Let's test it:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"julia> Example.plusone(1)\n2","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"Say we have a change of heart and decide the world is not ready for such elegant code. We can tell Pkg to stop using the local clone and use a registered version instead. We do this with free:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(tutorial) pkg> free Example","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"When you are done experimenting with tutorial, you can return to the default environment by running activate with no arguments:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(tutorial) pkg> activate\n\n(v1.1) pkg>","category":"page"},{"location":"getting-started/#Asking-for-Help","page":"2. Getting Started","title":"Asking for Help","text":"","category":"section"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"If you are ever stuck, you can ask Pkg for help:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> ?","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"You should see a list of available commands along with short descriptions. You can ask for more detailed help by specifying a command:","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"(v1.1) pkg> ?develop","category":"page"},{"location":"getting-started/","page":"2. Getting Started","title":"2. Getting Started","text":"This guide should help you get started with Pkg. Pkg has much more to offer in terms of powerful package management, read the full manual to learn more!","category":"page"},{"location":"registries/#**7.**-Registries","page":"7. Registries","title":"7. Registries","text":"","category":"section"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"Registries contain information about packages, such as available releases and dependencies, and where they can be downloaded. The General registry (https://github.com/JuliaRegistries/General) is the default one, and is installed automatically if there are no other registries installed.","category":"page"},{"location":"registries/#Managing-registries","page":"7. Registries","title":"Managing registries","text":"","category":"section"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"compat: Julia 1.1\nPkg's registry handling requires at least Julia 1.1.","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"Registries can be added, removed and updated from either the Pkg REPL or by using the functional API. In this section we will describe the REPL interface. The registry API is documented in the Registry API Reference section.","category":"page"},{"location":"registries/#Adding-registries","page":"7. Registries","title":"Adding registries","text":"","category":"section"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"A custom registry can be added with the registry add command from the Pkg REPL. Usually this will be done with a URL to the registry.","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"Adding a custom registry might cause the General registry to not be added automatically. In that case, we can simply add the General registry manually:","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"pkg> registry add https://github.com/JuliaRegistries/General\n   Cloning registry from \"https://github.com/JuliaRegistries/General\"\n     Added registry `General` to `~/.julia/registries/General`","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"and now all the packages registered in General are available for e.g. adding. To see which registries are currently installed you can use the registry status (or registry st) command","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"pkg> registry st\nRegistry Status\n [23338594] General (https://github.com/JuliaRegistries/General.git)","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"Registries are always added to the user depot, which is the first entry in DEPOT_PATH (cf. the Glossary section).","category":"page"},{"location":"registries/#Removing-registries","page":"7. Registries","title":"Removing registries","text":"","category":"section"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"Registries can be removed with the registry remove (or registry rm) command. Here we remove the General registry","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"pkg> registry rm General\n  Removing registry `General` from ~/.julia/registries/General\n\npkg> registry st\nRegistry Status\n  (no registries found)","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"In case there are multiple registries named General installed you have to disambiguate with the uuid, just as when manipulating packages, e.g.","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"pkg> registry rm General=23338594-aafe-5451-b93e-139f81909106\n  Removing registry `General` from ~/.julia/registries/General","category":"page"},{"location":"registries/#Updating-registries","page":"7. Registries","title":"Updating registries","text":"","category":"section"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"The registry update (or registry up) command is available to update registries. Here we update the General registry:","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"pkg> registry up General\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"and to update all installed registries just do:","category":"page"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"pkg> registry up\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General`","category":"page"},{"location":"registries/#Creating-and-maintaining-registries","page":"7. Registries","title":"Creating and maintaining registries","text":"","category":"section"},{"location":"registries/","page":"7. Registries","title":"7. Registries","text":"Pkg only provides client facilities for registries, rather than functionality to create or maintain them. However, Registrator.jl and LocalRegistry.jl provide ways to create and update registries, and RegistryCI.jl provides automated testing and merging functionality for maintaining a registry.","category":"page"},{"location":"glossary/#Glossary","page":"9. Glossary","title":"9. Glossary","text":"","category":"section"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Project: a source tree with a standard layout, including a src directory for the main body of Julia code, a test directory for testing the project, a docs directory for documentation files, and optionally a deps directory for a build script and its outputs. A project will typically also have a project file and may optionally have a manifest file:","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Project file: a file in the root directory of a project, named Project.toml (or JuliaProject.toml), describing metadata about the project, including its name, UUID (for packages), authors, license, and the names and UUIDs of packages and libraries that it depends on.\nManifest file: a file in the root directory of a project, named Manifest.toml (or JuliaManifest.toml), describing a complete dependency graph and exact versions of each package and library used by a project.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Package: a project which provides reusable functionality that can be used by other Julia projects via import X or using X. A package should have a project file with a uuid entry giving its package UUID. This UUID is used to identify the package in projects that depend on it.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"note: Note\nFor legacy reasons it is possible to load a package without a project file or UUID from the REPL or the top-level of a script. It is not possible, however, to load a package without a project file or UUID from a project with them. Once you've loaded from a project file, everything needs a project file and UUID.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Application: a project which provides standalone functionality not intended to be reused by other Julia projects. For example a web application or a commmand-line utility, or simulation/analytics code accompanying a scientific paper. An application may have a UUID but does not need one. An application may also provide global configuration options for packages it depends on. Packages, on the other hand, may not provide global configuration since that could conflict with the configuration of the main application.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"note: Note\nProjects vs. Packages vs. Applications:Project is an umbrella term: packages and applications are kinds of projects.\nPackages should have UUIDs, applications can have a UUIDs but don't need them.\nApplications can provide global configuration, whereas packages cannot.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Environment: the combination of the top-level name map provided by a project file combined with the dependency graph and map from packages to their entry points provided by a manifest file. For more detail see the manual section on code loading.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Explicit environment: an environment in the form of an explicit project file and an optional corresponding manifest file together in a directory. If the manifest file is absent then the implied dependency graph and location maps are empty.\nImplicit environment: an environment provided as a directory (without a project file or manifest file) containing packages with entry points of the form X.jl, X.jl/src/X.jl or X/src/X.jl. The top-level name map is implied by these entry points. The dependency graph is implied by the existence of project files inside of these package directories, e.g. X.jl/Project.toml or X/Project.toml. The dependencies of the X package are the dependencies in the corresponding project file if there is one. The location map is implied by the entry points themselves.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Registry: a source tree with a standard layout recording metadata about a registered set of packages, the tagged versions of them which are available, and which versions of packages are compatible or incompatible with each other. A registry is indexed by package name and UUID, and has a directory for each registered package providing the following metadata about it:","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"name – e.g. DataFrames\nUUID – e.g. a93c6f00-e57d-5684-b7b6-d8193f3e46c0\nrepository – e.g. https://github.com/JuliaData/DataFrames.jl.git\nversions – a list of all registered version tags","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"For each registered version of a package, the following information is provided:","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"its semantic version number – e.g. v1.2.3\nits git tree SHA-1 hash – e.g. 7ffb18ea3245ef98e368b02b81e8a86543a11103\na map from names to UUIDs of dependencies\nwhich versions of other packages it is compatible/incompatible with","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Dependencies and compatibility are stored in a compressed but human-readable format using ranges of package versions.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Depot: a directory on a system where various package-related resources live, including:","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"environments: shared named environments (e.g. v1.0, devtools)\nclones: bare clones of package repositories\ncompiled: cached compiled package images (.ji files)\nconfig: global configuration files (e.g. startup.jl)\ndev: default directory for package development\nlogs: log files (e.g. manifest_usage.toml, repl_history.jl)\npackages: installed package versions\nregistries: clones of registries (e.g. General)","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Load path: a stack of environments where package identities, their dependencies, and entry-points are searched for. The load path is controlled in Julia by the LOAD_PATH global variable which is populated at startup based on the value of the JULIA_LOAD_PATH environment variable. The first entry is your primary environment, often the current project, while later entries provide additional packages one may want to use from the REPL or top-level scripts.","category":"page"},{"location":"glossary/","page":"9. Glossary","title":"9. Glossary","text":"Depot path: a stack of depot locations where the package manager, as well as Julia's code loading mechanisms, look for registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files. The depot path is controlled by the Julia DEPOT_PATH global variable which is populated at startup based on the value of the JULIA_DEPOT_PATH environment variable. The first entry is the “user depot” and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.","category":"page"},{"location":"faq/#**8.**-FAQ","page":"8. FAQ","title":"8. FAQ","text":"","category":"section"},{"location":"faq/#Should-Manifest.toml-be-checked-in-to-the-package?","page":"8. FAQ","title":"Should Manifest.toml be checked in to the package?","text":"","category":"section"},{"location":"api/#API-Reference","page":"12. API Reference","title":"12. API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"This section describes the functional API for interacting with Pkg.jl. It is recommended to use the functional API, rather than the Pkg REPL mode, for non-interactive usage, for example in scripts.","category":"page"},{"location":"api/#General-API-Reference","page":"12. API Reference","title":"General API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"Certain options are generally useful and can be specified in any API call. You can specify these options by setting keyword arguments.","category":"page"},{"location":"api/#Redirecting-output","page":"12. API Reference","title":"Redirecting output","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"Use the io::IOBuffer keyword argument to redirect Pkg output. For example, Pkg.add(\"Example\"; io=devnull) will discard any output produced by the add call.","category":"page"},{"location":"api/#Package-API-Reference","page":"12. API Reference","title":"Package API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"In the Pkg REPL mode, packages (with associated version, UUID, URL etc) are parsed from strings, for example \"Package#master\",\"Package@v0.1\", \"www.mypkg.com/MyPkg#my/feature\".","category":"page"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"In the functional API, it is possible to use strings as arguments for simple commands (like Pkg.add([\"PackageA\", \"PackageB\"]), but more complicated commands, which e.g. specify URLs or version range, require the use of a more structured format over strings. This is done by creating an instance of PackageSpec which is passed in to functions.","category":"page"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"PackageSpec\nPackageMode\nUpgradeLevel\nPkg.add\nPkg.develop\nPkg.activate\nPkg.rm\nPkg.update\nPkg.test\nPkg.build\nPkg.pin\nPkg.free\nPkg.instantiate\nPkg.resolve\nPkg.gc\nPkg.status\nPkg.precompile\nPkg.offline\nPkg.setprotocol!\nPkg.dependencies\nPkg.project\nPkg.undo\nPkg.redo","category":"page"},{"location":"api/#Pkg.PackageSpec","page":"12. API Reference","title":"Pkg.PackageSpec","text":"PackageSpec(name::String, [uuid::UUID, version::VersionNumber])\nPackageSpec(; name, url, path, subdir, rev, version, mode, level)\n\nA PackageSpec is a representation of a package with various metadata. This includes:\n\nThe name of the package.\nThe package's unique uuid.\nA version (for example when adding a package). When upgrading, can also be an instance of the enum UpgradeLevel.\nA url and an optional git revision. rev can be a branch name or a git commit SHA1.\nA local path. This is equivalent to using the url argument but can be more descriptive.\nA subdir which can be used when adding a package that is not in the root of a repository.\n\nMost functions in Pkg take a Vector of PackageSpec and do the operation on all the packages in the vector.\n\ncompat: Julia 1.5\nMany functions that take a PackageSpec or a Vector{PackageSpec} can be called with a more concise notation with NamedTuples. For example, Pkg.add can be called either as the explicit or concise versions as:Explicit Concise\nPkg.add(PackageSpec(name=\"Package\")) Pkg.add(name = \"Package\")\nPkg.add(PackageSpec(url=\"www.myhost.com/MyPkg\"))) Pkg.add(name = \"Package\")\nPkg.add([PackageSpec(name=\"Package\"), PackageSpec(path=\"/MyPkg\"]) Pkg.add([(;name=\"Package\"), (;path=\"MyPkg\")])\n\nBelow is a comparison between the REPL mode and the functional API:\n\nREPL API\nPackage PackageSpec(\"Package\")\nPackage@0.2 PackageSpec(name=\"Package\", version=\"0.2\")\nPackage=a67d... PackageSpec(name=\"Package\", uuid=\"a67d...\")\nPackage#master PackageSpec(name=\"Package\", rev=\"master\")\nlocal/path#feature PackageSpec(path=\"local/path\"; rev=\"feature\")\nwww.mypkg.com PackageSpec(url=\"www.mypkg.com\")\n--major Package PackageSpec(name=\"Package\", version=PKGLEVEL_MAJOR)\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.PackageMode","page":"12. API Reference","title":"Pkg.PackageMode","text":"PackageMode\n\nAn enum with the instances\n\nPKGMODE_MANIFEST\nPKGMODE_PROJECT\n\nDetermines if operations should be made on a project or manifest level. Used as an argument to Pkg.rm, Pkg.update and Pkg.status.\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.UpgradeLevel","page":"12. API Reference","title":"Pkg.UpgradeLevel","text":"UpgradeLevel\n\nAn enum with the instances\n\nUPLEVEL_FIXED\nUPLEVEL_PATCH\nUPLEVEL_MINOR\nUPLEVEL_MAJOR\n\nDetermines how much a package is allowed to be updated. Used as an argument to  PackageSpec or as an argument to Pkg.update.\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.add","page":"12. API Reference","title":"Pkg.add","text":"Pkg.add(pkg::Union{String, Vector{String}}; preserve=PRESERVE_TIERED)\nPkg.add(pkg::Union{PackageSpec, Vector{PackageSpec}}; preserve=PRESERVE_TIERED)\n\nAdd a package to the current project. This package will be available by using the import and using keywords in the Julia REPL, and if the current project is a package, also inside that package.\n\nResolution Tiers\n\nPkg resolves the set of packages in your environment using a tiered algorithm. The preserve keyword argument allows you to key into a specific tier in the resolve algorithm. The following table describes the argument values for preserve (in order of strictness):\n\nValue Description\nPRESERVE_ALL Preserve the state of all existing dependencies (including recursive dependencies)\nPRESERVE_DIRECT Preserve the state of all existing direct dependencies\nPRESERVE_SEMVER Preserve semver-compatible versions of direct dependencies\nPRESERVE_NONE Do not attempt to preserve any version information\nPRESERVE_TIERED Use the tier which will preserve the most version information (this is the default)\n\nExamples\n\nPkg.add(\"Example\") # Add a package from registry\nPkg.add(\"Example\"; preserve=Pkg.PRESERVE_ALL) # Add the `Example` package and preserve existing dependencies\nPkg.add(name=\"Example\", version=\"0.3\") # Specify version; latest release in the 0.3 series\nPkg.add(name=\"Example\", version=\"0.3.1\") # Specify version; exact release\nPkg.add(url=\"https://github.com/JuliaLang/Example.jl\", rev=\"master\") # From url to remote gitrepo\nPkg.add(url=\"/remote/mycompany/juliapackages/OurPackage\") # From path to local gitrepo\nPkg.add(url=\"https://github.com/Company/MonoRepo\", subdir=\"juliapkgs/Package.jl)\") # With subdir\n\nSee also PackageSpec, Pkg.develop.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.develop","page":"12. API Reference","title":"Pkg.develop","text":"Pkg.develop(pkg::Union{String, Vector{String}}; io::IO=stderr)\nPkg.develop(pkgs::Union{Packagespec, Vector{Packagespec}}; io::IO=stderr)\n\nMake a package available for development by tracking it by path. If pkg is given with only a name or by a URL, the package will be downloaded to the location specified by the environment variable JULIA_PKG_DEVDIR, with joinpath(DEPOT_PATH[1],\"dev\") being the default.\n\nIf pkg is given as a local path, the package at that path will be tracked.\n\nExamples\n\n# By name\nPkg.develop(\"Example\")\n\n# By url\nPkg.develop(url=\"https://github.com/JuliaLang/Compat.jl\")\n\n# By path\nPkg.develop(path=\"MyJuliaPackages/Package.jl\")\n\nSee also PackageSpec, Pkg.add.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.activate","page":"12. API Reference","title":"Pkg.activate","text":"Pkg.activate([s::String]; shared::Bool=false, io::IO=stderr)\nPkg.activate(; temp::Bool=false, shared::Bool=false, io::IO=stderr)\n\nActivate the environment at s. The active environment is the environment that is modified by executing package commands. The logic for what path is activated is as follows:\n\nIf shared is true, the first existing environment named s from the depots in the depot stack will be activated. If no such environment exists, create and activate that environment in the first depot.\nIf temp is true this will create and activate a temporary environment which will be deleted when the julia process is exited.\nIf s is an existing path, then activate the environment at that path.\nIf s is a package in the current project and s is tracking a path, then activate the environment at the tracked path.\nOtherwise, s is interpreted as a non-existing path, which is then activated.\n\nIf no argument is given to activate, then activate the home project. The home project is specified by either the --project command line option to the julia executable, or the JULIA_PROJECT environment variable.\n\nExamples\n\nPkg.activate()\nPkg.activate(\"local/path\")\nPkg.activate(\"MyDependency\")\nPkg.activate(; temp=true)\n\ncompat: Julia 1.4\nthe temp option requires at least Julia 1.4.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.rm","page":"12. API Reference","title":"Pkg.rm","text":"Pkg.rm(pkg::Union{String, Vector{String}}; mode::PackageMode = PKGMODE_PROJECT)\nPkg.rm(pkg::Union{PackageSpec, Vector{PackageSpec}}; mode::PackageMode = PKGMODE_PROJECT)\n\nRemove a package from the current project. If mode is equal to PKGMODE_MANIFEST also remove it from the manifest including all recursive dependencies of pkg.\n\nSee also PackageSpec, PackageMode.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.update","page":"12. API Reference","title":"Pkg.update","text":"Pkg.update(; level::UpgradeLevel=UPLEVEL_MAJOR, mode::PackageMode = PKGMODE_PROJECT)\nPkg.update(pkg::Union{String, Vector{String}})\nPkg.update(pkg::Union{PackageSpec, Vector{PackageSpec}})\n\nUpdate a package pkg. If no posistional argument is given, update all packages in the manifest if mode is PKGMODE_MANIFEST and packages in both manifest and project if mode is PKGMODE_PROJECT. If no positional argument is given, level can be used to control by how much packages are allowed to be upgraded (major, minor, patch, fixed).\n\nSee also PackageSpec, PackageMode, UpgradeLevel.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.test","page":"12. API Reference","title":"Pkg.test","text":"Pkg.test(; kwargs...)\nPkg.test(pkg::Union{String, Vector{String}; kwargs...)\nPkg.test(pkgs::Union{PackageSpec, Vector{PackageSpec}}; kwargs...)\n\nKeyword arguments:\n\ncoverage::Bool=false: enable or disable generation of coverage statistics.\njulia_args::Union{Cmd, Vector{String}}: options to be passed the test process.\ntest_args::Union{Cmd, Vector{String}}: test arguments (ARGS) available in the test process.\n\ncompat: Julia 1.3\njulia_args and test_args requires at least Julia 1.3.\n\nRun the tests for package pkg, or for the current project (which thus needs to be a package) if no positional argument is given to Pkg.test. A package is tested by running its test/runtests.jl file.\n\nThe tests are run by generating a temporary environment with only pkg and its (recursive) dependencies in it. If a manifest exists, the versions in that manifest are used, otherwise a feasible set of packages is resolved and installed.\n\nDuring the tests, test-specific dependencies are active, which are given in the project file as e.g.\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]\n\nThe tests are executed in a new process with check-bounds=yes and by default startup-file=no. If using the startup file (~/.julia/config/startup.jl) is desired, start julia with --startup-file=yes. Inlining of functions during testing can be disabled (for better coverage accuracy) by starting julia with --inline=no.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.build","page":"12. API Reference","title":"Pkg.build","text":"Pkg.build(; verbose = false, io::IO=stderr)\nPkg.build(pkg::Union{String, Vector{String}}; verbose = false, io::IO=stderr)\nPkg.build(pkgs::Union{PackageSpec, Vector{PackageSpec}}; verbose = false, io::IO=stderr)\n\nRun the build script in deps/build.jl for pkg and all of its dependencies in depth-first recursive order. If no argument is given to build, the current project is built, which thus needs to be a package. This function is called automatically on any package that gets installed for the first time. verbose = true prints the build output to stdout/stderr instead of redirecting to the build.log file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.pin","page":"12. API Reference","title":"Pkg.pin","text":"Pkg.pin(pkg::Union{String, Vector{String}}; io::IO=stderr)\nPkg.pin(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr)\n\nPin a package to the current version (or the one given in the PackageSpec) or to a certain git revision. A pinned package is never updated.\n\nExamples\n\nPkg.pin(\"Example\")\nPkg.pin(name=\"Example\", version=\"0.3.1\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.free","page":"12. API Reference","title":"Pkg.free","text":"Pkg.free(pkg::Union{String, Vector{String}}; io::IO=stderr)\nPkg.free(pkgs::Union{PackageSpec, Vector{PackageSpec}}; io::IO=stderr)\n\nIf pkg is pinned, remove the pin. If pkg is tracking a path, e.g. after Pkg.develop, go back to tracking registered versions.\n\nExamples\n\nPkg.free(\"Package\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.instantiate","page":"12. API Reference","title":"Pkg.instantiate","text":"Pkg.instantiate(; verbose = false, io::IO=stderr)\n\nIf a Manifest.toml file exists in the active project, download all the packages declared in that manifest. Otherwise, resolve a set of feasible packages from the Project.toml files and install them. verbose = true prints the build output to stdout/stderr instead of redirecting to the build.log file. If no Project.toml exist in the current active project, create one with all the dependencies in the manifest and instantiate the resulting project.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.resolve","page":"12. API Reference","title":"Pkg.resolve","text":"Pkg.resolve(; io::IO=stderr)\n\nUpdate the current manifest with potential changes to the dependency graph from packages that are tracking a path.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.gc","page":"12. API Reference","title":"Pkg.gc","text":"Pkg.gc(; collect_delay::Period=Day(7), io::IO=stderr)\n\nGarbage-collect package and artifact installations by sweeping over all known Manifest.toml and Artifacts.toml files, noting those that have been deleted, and then finding artifacts and packages that are thereafter not used by any other projects, marking them as \"orphaned\".  This method will only remove orphaned objects (package versions, artifacts, and scratch spaces) that have been continually un-used for a period of collect_delay; which defaults to seven days.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.status","page":"12. API Reference","title":"Pkg.status","text":"Pkg.status([pkgs...]; mode::PackageMode=PKGMODE_PROJECT, diff::Bool=false, compat::Bool=false, io::IO=stdout)\n\nPrint out the status of the project/manifest. If mode is PKGMODE_PROJECT, print out status only about the packages that are in the project (explicitly added). If mode is PKGMODE_MANIFEST, print status also about those in the manifest (recursive dependencies). If there are any packages listed as arguments, the output will be limited to those packages.\n\nSetting diff=true will, if the environment is in a git repository, limit the output to the difference as compared to the last git commit.\n\nSetting outdated=true will only show packages that are not on the latest version, their maximum version and why they are not on the latest version (either due to other packages holding them back due to compatibility constraints, or due to compatibility in the project file). As an example, a status output like:\n\npkg> Pkg.status(; outdated=true)\nStatus `Manifest.toml`\n [a8cc5b0e] Crayons v2.0.0 [<v3.0.0], (<v4.0.4)\n [b8a86587] NearestNeighbors v0.4.8 (<v0.4.9) [compat]\n [2ab3a3ac] LogExpFunctions v0.2.5 (<v0.3.0): SpecialFunctions\n\nmeans that the latest version of Crayons is 4.0.4 but the latest version compatible with the [compat] section in the current project is 3.0.0. The latest version of NearestNeighbors is 0.4.9 but due to compat constrains in the project it is held back to 0.4.8. The latest version of LogExpFunctions is 0.3.0 but SpecialFunctions is holding it back to 0.2.5.\n\nSee Pkg.project and Pkg.dependencies to get the project/manifest status as a Julia object instead of printing it.\n\ncompat: Julia 1.1\nPkg.status with package arguments requires at least Julia 1.1.\n\ncompat: Julia 1.3\nThe diff keyword argument requires at least Julia 1.3. In earlier versions diff=true is the default for environments in git repositories.\n\ncompat: Julia 1.8\nThe outdated keyword argument reguires at least Julia 1.8\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.precompile","page":"12. API Reference","title":"Pkg.precompile","text":"Pkg.precompile(; strict::Bool=false)\nPkg.precompile(pkg; strict::Bool=false)\nPkg.precompile(pkgs; strict::Bool=false)\n\nPrecompile all or specific dependencies of the project in parallel.\n\nnote: Note\nErrors will only throw when precompiling the top-level dependencies, given that not all manifest dependencies may be loaded by the top-level dependencies on the given system. This can be overridden to make errors in all dependencies throw by setting the kwarg strict to true\n\nnote: Note\nThis method is called automatically after any Pkg action that changes the manifest. Any packages that have previously errored during precompilation won't be retried in auto mode until they have changed. To disable automatic precompilation set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0. To manually control the number of tasks used set ENV[\"JULIA_NUM_PRECOMPILE_TASKS\"].\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3. On earlier versions you can use Pkg.API.precompile() or the precompile Pkg REPL command.\n\ncompat: Julia 1.8\nSpecifying packages to precompile requires at least Julia 1.8.\n\nExamples\n\nPkg.precompile()\nPkg.precompile(\"Foo\")\nPkg.precompile([\"Foo\", \"Bar\"])\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.offline","page":"12. API Reference","title":"Pkg.offline","text":"Pkg.offline(b::Bool=true)\n\nEnable (b=true) or disable (b=false) offline mode.\n\nIn offline mode Pkg tries to do as much as possible without connecting to internet. For example, when adding a package Pkg only considers versions that are already downloaded in version resolution.\n\nTo work in offline mode across Julia sessions you can set the environment variable JULIA_PKG_OFFLINE to \"true\".\n\ncompat: Julia 1.5\nPkg's offline mode requires Julia 1.5 or later.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.setprotocol!","page":"12. API Reference","title":"Pkg.setprotocol!","text":"setprotocol!(;\n    domain::AbstractString = \"github.com\",\n    protocol::Union{Nothing, AbstractString}=nothing\n)\n\nSet the protocol used to access hosted packages when adding a url or developing a package. Defaults to delegating the choice to the package developer (protocol === nothing). Other choices for protocol are \"https\" or \"git\".\n\nExamples\n\njulia> Pkg.setprotocol!(domain = \"github.com\", protocol = \"ssh\")\n\njulia> Pkg.setprotocol!(domain = \"gitlab.mycompany.com\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.dependencies","page":"12. API Reference","title":"Pkg.dependencies","text":"Pkg.dependencies()::Dict{UUID, PackageInfo}\n\ncompat: Julia 1.4\nThis feature requires Julia 1.4, and is considered experimental.\n\nQuery the dependency graph. The result is a Dict that maps a package UUID to a PackageInfo struct representing the dependency (a package).\n\nPackageInfo fields\n\nField Description\nname The name of the package\nversion The version of the package (this is Nothing for stdlibs)\nis_direct_dep The package is a direct dependency\nis_tracking_path Whether a package is directly tracking a directory\nis_pinned Whether a package is pinned\nsource The directory containing the source code for that package\ndependencies The dependencies of that package as a vector of UUIDs\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.project","page":"12. API Reference","title":"Pkg.project","text":"Pkg.project()::ProjectInfo\n\ncompat: Julia 1.4\nThis feature requires Julia 1.4, and is considered experimental.\n\nRequest a ProjectInfo struct which contains information about the active project.\n\nProjectInfo fields\n\nField Description\nname The project's name\nuuid The project's UUID\nversion The project's version\ndependencies The project's direct dependencies as a Dict which maps dependency name to dependency UUID\npath The location of the project file which defines the active project\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.undo","page":"12. API Reference","title":"Pkg.undo","text":"undo()\n\nUndoes the latest change to the active project. Only states in the current session are stored, up to a maximum of 50 states.\n\nSee also: redo.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.redo","page":"12. API Reference","title":"Pkg.redo","text":"redo()\n\nRedoes the changes from the latest undo.\n\n\n\n\n\n","category":"function"},{"location":"api/#Registry-API-Reference","page":"12. API Reference","title":"Registry API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"compat: Julia 1.1\nPkg's registry handling requires at least Julia 1.1.","category":"page"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"The functional API for registries uses RegistrySpecs, similar to PackageSpec.","category":"page"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"RegistrySpec\nPkg.Registry.add\nPkg.Registry.rm\nPkg.Registry.update\nPkg.Registry.status","category":"page"},{"location":"api/#Pkg.RegistrySpec","page":"12. API Reference","title":"Pkg.RegistrySpec","text":"RegistrySpec(name::String)\nRegistrySpec(; name, url, path)\n\nA RegistrySpec is a representation of a registry with various metadata, much like PackageSpec.\n\nMost registry functions in Pkg take a Vector of RegistrySpec and do the operation on all the registries in the vector.\n\ncompat: Julia 1.1\nPkg's registry handling requires at least Julia 1.1.\n\nExamples\n\nBelow is a comparison between the REPL mode and the functional API::\n\nREPL API\nRegistry RegistrySpec(\"Registry\")\nRegistry=a67d... RegistrySpec(name=\"Registry\", uuid=\"a67d...\")\nlocal/path RegistrySpec(path=\"local/path\")\nwww.myregistry.com RegistrySpec(url=\"www.myregistry.com\")\n\n\n\n\n\n","category":"type"},{"location":"api/#Pkg.Registry.add","page":"12. API Reference","title":"Pkg.Registry.add","text":"Pkg.Registry.add(url::String)\nPkg.Registry.add(registry::RegistrySpec)\n\nAdd new package registries.\n\ncompat: Julia 1.1\nPkg's registry handling requires at least Julia 1.1.\n\nExamples\n\nPkg.Registry.add(\"General\")\nPkg.Registry.add(RegistrySpec(uuid = \"23338594-aafe-5451-b93e-139f81909106\"))\nPkg.Registry.add(RegistrySpec(url = \"https://github.com/JuliaRegistries/General.git\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.rm","page":"12. API Reference","title":"Pkg.Registry.rm","text":"Pkg.Registry.rm(registry::String)\nPkg.Registry.rm(registry::RegistrySpec)\n\nRemove registries.\n\ncompat: Julia 1.1\nPkg's registry handling requires at least Julia 1.1.\n\nExamples\n\nPkg.Registry.rm(\"General\")\nPkg.Registry.rm(RegistrySpec(uuid = \"23338594-aafe-5451-b93e-139f81909106\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.update","page":"12. API Reference","title":"Pkg.Registry.update","text":"Pkg.Registry.update()\nPkg.Registry.update(registry::RegistrySpec)\nPkg.Registry.update(registry::Vector{RegistrySpec})\n\nUpdate registries. If no registries are given, update all available registries.\n\ncompat: Julia 1.1\nPkg's registry handling requires at least Julia 1.1.\n\nExamples\n\nPkg.Registry.update()\nPkg.Registry.update(\"General\")\nPkg.Registry.update(RegistrySpec(uuid = \"23338594-aafe-5451-b93e-139f81909106\"))\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Registry.status","page":"12. API Reference","title":"Pkg.Registry.status","text":"Pkg.Registry.status()\n\nDisplay information about available registries.\n\ncompat: Julia 1.1\nPkg's registry handling requires at least Julia 1.1.\n\nExamples\n\nPkg.Registry.status()\n\n\n\n\n\n","category":"function"},{"location":"api/#Artifacts-Reference","page":"12. API Reference","title":"Artifacts API Reference","text":"","category":"section"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"compat: Julia 1.3\nPkg's artifacts API requires at least Julia 1.3.","category":"page"},{"location":"api/","page":"12. API Reference","title":"12. API Reference","text":"Pkg.Artifacts.create_artifact\nPkg.Artifacts.remove_artifact\nPkg.Artifacts.verify_artifact\nPkg.Artifacts.bind_artifact!\nPkg.Artifacts.unbind_artifact!\nPkg.Artifacts.download_artifact\nPkg.Artifacts.ensure_artifact_installed\nPkg.Artifacts.ensure_all_artifacts_installed\nPkg.Artifacts.archive_artifact","category":"page"},{"location":"api/#Pkg.Artifacts.create_artifact","page":"12. API Reference","title":"Pkg.Artifacts.create_artifact","text":"create_artifact(f::Function)\n\nCreates a new artifact by running f(artifact_path), hashing the result, and moving it to the artifact store (~/.julia/artifacts on a typical installation).  Returns the identifying tree hash of this artifact.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.remove_artifact","page":"12. API Reference","title":"Pkg.Artifacts.remove_artifact","text":"remove_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nRemoves the given artifact (identified by its SHA1 git tree hash) from disk.  Note that if an artifact is installed in multiple depots, it will be removed from all of them.  If an overridden artifact is requested for removal, it will be silently ignored; this method will never attempt to remove an overridden artifact.\n\nIn general, we recommend that you use Pkg.gc() to manage artifact installations and do not use remove_artifact() directly, as it can be difficult to know if an artifact is being used by another package.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.verify_artifact","page":"12. API Reference","title":"Pkg.Artifacts.verify_artifact","text":"verify_artifact(hash::SHA1; honor_overrides::Bool=false)\n\nVerifies that the given artifact (identified by its SHA1 git tree hash) is installed on- disk, and retains its integrity.  If the given artifact is overridden, skips the verification unless honor_overrides is set to true.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.bind_artifact!","page":"12. API Reference","title":"Pkg.Artifacts.bind_artifact!","text":"bind_artifact!(artifacts_toml::String, name::String, hash::SHA1;\n               platform::Union{AbstractPlatform,Nothing} = nothing,\n               download_info::Union{Vector{Tuple},Nothing} = nothing,\n               lazy::Bool = false,\n               force::Bool = false)\n\nWrites a mapping of name -> hash within the given (Julia)Artifacts.toml file. If platform is not nothing, this artifact is marked as platform-specific, and will be a multi-mapping.  It is valid to bind multiple artifacts with the same name, but different platforms and hash'es within the same artifacts_toml.  If force is set to true, this will overwrite a pre-existant mapping, otherwise an error is raised.\n\ndownload_info is an optional vector that contains tuples of URLs and a hash.  These URLs will be listed as possible locations where this artifact can be obtained.  If lazy is set to true, even if download information is available, this artifact will not be downloaded until it is accessed via the artifact\"name\" syntax, or ensure_artifact_installed() is called upon it.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.unbind_artifact!","page":"12. API Reference","title":"Pkg.Artifacts.unbind_artifact!","text":"unbind_artifact!(artifacts_toml::String, name::String; platform = nothing)\n\nUnbind the given name from an (Julia)Artifacts.toml file. Silently fails if no such binding exists within the file.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.download_artifact","page":"12. API Reference","title":"Pkg.Artifacts.download_artifact","text":"download_artifact(tree_hash::SHA1, tarball_url::String, tarball_hash::String;\n                  verbose::Bool = false, io::IO=stderr)\n\nDownload/install an artifact into the artifact store.  Returns true on success.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.ensure_artifact_installed","page":"12. API Reference","title":"Pkg.Artifacts.ensure_artifact_installed","text":"ensure_artifact_installed(name::String, artifacts_toml::String;\n                          platform::AbstractPlatform = HostPlatform(),\n                          pkg_uuid::Union{Base.UUID,Nothing}=nothing,\n                          verbose::Bool = false,\n                          quiet_download::Bool = false,\n                          io::IO=stderr)\n\nEnsures an artifact is installed, downloading it via the download information stored in artifacts_toml if necessary.  Throws an error if unable to install.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.ensure_all_artifacts_installed","page":"12. API Reference","title":"Pkg.Artifacts.ensure_all_artifacts_installed","text":"ensure_all_artifacts_installed(artifacts_toml::String;\n                               platform = HostPlatform(),\n                               pkg_uuid = nothing,\n                               include_lazy = false,\n                               verbose = false,\n                               quiet_download = false,\n                               io::IO=stderr)\n\nInstalls all non-lazy artifacts from a given (Julia)Artifacts.toml file. package_uuid must be provided to properly support overrides from Overrides.toml entries in depots.\n\nIf include_lazy is set to true, then lazy packages will be installed as well.\n\nThis function is deprecated and should be replaced with the following snippet:\n\nartifacts = select_downloadable_artifacts(artifacts_toml; platform, include_lazy)\nfor name in keys(artifacts)\n    ensure_artifact_installed(name, artifacts[name], artifacts_toml; platform=platform)\nend\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\nwarning: Warning\nThis function is deprecated in Julia 1.6 and will be removed in a future version. Use select_downloadable_artifacts() and ensure_artifact_installed() instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pkg.Artifacts.archive_artifact","page":"12. API Reference","title":"Pkg.Artifacts.archive_artifact","text":"archive_artifact(hash::SHA1, tarball_path::String; honor_overrides::Bool=false)\n\nArchive an artifact into a tarball stored at tarball_path, returns the SHA256 of the resultant tarball as a hexidecimal string. Throws an error if the artifact does not exist.  If the artifact is overridden, throws an error unless honor_overrides is set.\n\ncompat: Julia 1.3\nThis function requires at least Julia 1.3.\n\n\n\n\n\n","category":"function"},{"location":"managing-packages/#**3.**-Managing-Packages","page":"3. Managing Packages","title":"3. Managing Packages","text":"","category":"section"},{"location":"managing-packages/#Adding-packages","page":"3. Managing Packages","title":"Adding packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"There are two ways of adding packages, either using the add command or the dev command. The most frequently used is add and its usage is described first.","category":"page"},{"location":"managing-packages/#Adding-registered-packages","page":"3. Managing Packages","title":"Adding registered packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"In the Pkg REPL, packages can be added with the add command followed by the name of the package, for example:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> add Example\n   Cloning default registries into /Users/kristoffer/.julia/registries\n   Cloning registry General from \"https://github.com/JuliaRegistries/General.git\"\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [7876af07] + Example v0.5.1\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7876af07] + Example v0.5.1\n  [8dfed614] + Test","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Here we added the package Example to the current project. In this example, we are using a fresh Julia installation, and this is our first time adding a package using Pkg. By default, Pkg clones Julia's General registry, and uses this registry to look up packages requested for inclusion in the current environment. The status update shows a short form of the package UUID to the left, then the package name, and the version. Since standard libraries (e.g. Test) are shipped with Julia, they do not have a version. The project status contains the packages you have added yourself, in this case, Example:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> st\n    Status `Project.toml`\n  [7876af07] Example v0.5.1","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The manifest status shows all the packages in the environment, including recursive dependencies:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> st --manifest\n    Status `Manifest.toml`\n  [7876af07] Example v0.5.1\n  [8dfed614] Test","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"It is possible to add multiple packages in one command as pkg> add A B C.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"After a package is added to the project, it can be loaded in Julia:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"julia> using Example\n\njulia> Example.hello(\"User\")\n\"Hello, User\"","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"A specific version can be installed by appending a version after a @ symbol, e.g. @v0.4, to the package name:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> add Example@0.4\n Resolving package versions...\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [7876af07] + Example v0.4.1\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7876af07] + Example v0.4.1","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"If a branch (or a certain commit) of Example has a hotfix that is not yet included in a registered version, we can explicitly track that branch (or commit) by appending #branchname (or #commitSHA1) to the package name:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> add Example#master\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\n Resolving package versions...\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git)","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The status output now shows that we are tracking the master branch of Example. When updating packages, updates are pulled from that branch.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"note: Note\nIf we would specify a commit id instead of a branch name, e.g. add Example#025cf7e, then we would effectively \"pin\" the package to that commit. This is because the commit id always point to the same thing unlike a branch, which may be updated.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"To go back to tracking the registry version of Example, the command free is used:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> free Example\n Resolving package versions...\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [7876af07] ~ Example v0.5.1+ #master (https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7876af07] ~ Example v0.5.1+ #master )https://github.com/JuliaLang/Example.jl.git) ⇒ v0.5.1","category":"page"},{"location":"managing-packages/#Adding-unregistered-packages","page":"3. Managing Packages","title":"Adding unregistered packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"If a package is not in a registry, it can be added by specifying a URL to the repository:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> add https://github.com/fredrikekre/ImportMacros.jl\n  Updating git-repo `https://github.com/fredrikekre/ImportMacros.jl`\n Resolving package versions...\nDownloaded MacroTools ─ v0.4.1\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [e6797606] + ImportMacros v0.0.0 # (https://github.com/fredrikekre/ImportMacros.jl)\n  [1914dd2f] + MacroTools v0.4.1","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The dependencies of the unregistered package (here MacroTools) got installed. For unregistered packages we could have given a branch name (or commit SHA1) to track using #, just like for registered packages.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"If you want to add a package using the SSH-based git protocol, you have to use quotes because the URL contains a @. For example,","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> add \"git@github.com:fredrikekre/ImportMacros.jl.git\"\n    Cloning git-repo `git@github.com:fredrikekre/ImportMacros.jl.git`\n   Updating git-repo `git@github.com:fredrikekre/ImportMacros.jl.git`\n   Updating registry at `~/.julia/registries/General`\n  Resolving package versions...\nUpdating `~/.julia/environments/v1/Project.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`\nUpdating `~/.julia/environments/v1/Manifest.toml`\n  [92a963f6] + ImportMacros v1.0.0 `git@github.com:fredrikekre/ImportMacros.jl.git#master`","category":"page"},{"location":"managing-packages/#Adding-a-local-package","page":"3. Managing Packages","title":"Adding a local package","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Instead of giving a URL of a git repo to add we could instead have given a local path to a git repo. This works similar to adding a URL. The local repository will be tracked (at some branch) and updates from that local repo are pulled when packages are updated. Note tracking a package through add is distinct from develop: changes to files in the local package repository will not immediately be reflected when loading that package. The changes would have to be committed and the packages updated in order to pull in the changes.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"In addition, it is possible to add packages relatively to the Manifest.toml file, see Developing packages for an example.","category":"page"},{"location":"managing-packages/#developing","page":"3. Managing Packages","title":"Developing packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"By only using add your Manifest will always have a \"reproducible state\", in other words, as long as the repositories and registries used are still accessible it is possible to retrieve the exact state of all the dependencies in the project. This has the advantage that you can send your project (Project.toml and Manifest.toml) to someone else and they can \"instantiate\" that project in the same state as you had it locally. However, when you are developing a package, it is more convenient to load packages at their current state at some path. For this reason, the dev command exists.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Let's try to dev a registered package:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> dev Example\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\n Resolving package versions...\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7876af07] + Example v0.5.1+ [`~/.julia/dev/Example`]","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The dev command fetches a full clone of the package to ~/.julia/dev/ (the path can be changed by setting the environment variable JULIA_PKG_DEVDIR, the default being joinpath(DEPOT_PATH[1],\"dev\")). When importing Example julia will now import it from ~/.julia/dev/Example and whatever local changes have been made to the files in that path are consequently reflected in the code loaded. When we used add we said that we tracked the package repository, we here say that we track the path itself. Note the package manager will never touch any of the files at a tracked path. It is therefore up to you to pull updates, change branches etc. If we try to dev a package at some branch that already exists at ~/.julia/dev/ the package manager we will simply use the existing path. For example:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> dev Example\n  Updating git-repo `https://github.com/JuliaLang/Example.jl.git`\n[ Info: Path `/Users/kristoffer/.julia/dev/Example` exists and looks like the correct package, using existing path instead of cloning","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Note the info message saying that it is using the existing path. When tracking a path, the package manager will never modify the files at that path.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"If dev is used on a local path, that path to that package is recorded and used when loading that package. The path will be recorded relative to the project file, unless it is given as an absolute path.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"To stop tracking a path and use the registered version again, use free:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> free Example\n Resolving package versions...\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7876af07] ↓ Example v0.5.1+ [`~/.julia/dev/Example`] ⇒ v0.5.1","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"It should be pointed out that by using dev your project is now inherently stateful. Its state depends on the current content of the files at the path and the manifest cannot be \"instantiated\" by someone else without knowing the exact content of all the packages that are tracking a path.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Note that if you add a dependency to a package that tracks a local path, the Manifest (which contains the whole dependency graph) will become out of sync with the actual dependency graph. This means that the package will not be able to load that dependency since it is not recorded in the Manifest. To synchronize the Manifest, use the REPL command resolve.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"In addition to absolute paths, add and dev can accept relative paths to packages. In this case, the relative path from the active project to the package is stored. This approach is useful when the relative location of tracked dependencies is more important than their absolute location. For example, the tracked dependencies can be stored inside of the active project directory. The whole directory can be moved and Pkg will still be able to find the dependencies because their path relative to the active project is preserved even though their absolute path has changed.","category":"page"},{"location":"managing-packages/#Adding-a-package-in-a-subdirectory-of-a-repository","page":"3. Managing Packages","title":"Adding a package in a subdirectory of a repository","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"If the package you want to add by URL is not in the root of the repository, then you need to manually pass the subdir keyword to Pkg.add or PackageSpec. For instance, to add the SnoopCompileCore package in the SnoopCompile repository:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"julia> Pkg.add(url=\"https://github.com/timholy/SnoopCompile.jl.git\", subdir=\"SnoopCompileCore\")\n     Cloning git-repo `https://github.com/timholy/SnoopCompile.jl.git`\n    Updating git-repo `https://github.com/timholy/SnoopCompile.jl.git`\n   Resolving package versions...\n    Updating `~/.julia/environments/v1.6/Project.toml`\n  [e2b509da] + SnoopCompileCore v2.7.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n    Updating `~/.julia/environments/v1.6/Manifest.toml`\n  [e2b509da] + SnoopCompileCore v2.7.0 `https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore#master`\n  [9e88b42a] + Serialization","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Another way is to use the Pkg REPL with <repo_url>:<subdir> format:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"pkg> add https://github.com/timholy/SnoopCompile.jl.git:SnoopCompileCore # git HTTPS protocol\n...\n\npkg> add \"git@github.com:timholy/SnoopCompile.jl.git\":SnoopCompileCore # git SSH protocol\n...","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"compat: Julia 1.5\nThe Pkg REPL for packages in subdirectory requires at least Julia 1.5.","category":"page"},{"location":"managing-packages/#Removing-packages","page":"3. Managing Packages","title":"Removing packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Packages can be removed from the current project by using pkg> rm Package. This will only remove packages that exist in the project; to remove a package that only exists as a dependency use pkg> rm --manifest DepPackage. Note that this will remove all packages that depend on DepPackage.","category":"page"},{"location":"managing-packages/#updating","page":"3. Managing Packages","title":"Updating packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"When new versions of packages that the project is using are released, it is a good idea to update. Simply calling up will try to update all the dependencies of the project to the latest compatible version. Sometimes this is not what you want. You can specify a subset of the dependencies to upgrade by giving them as arguments to up, e.g:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> up Example","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"If Example has a dependency which is also a dependency for another explicitly added package, that dependency will not be updated. If you only want to update the minor version of packages, to reduce the risk that your project breaks, you can give the --minor flag, e.g:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> up --minor Example","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Packages that track a local repository are not updated when a minor upgrade is done. Packages that track a path are never touched by the package manager.","category":"page"},{"location":"managing-packages/#Pinning-a-package","page":"3. Managing Packages","title":"Pinning a package","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"A pinned package will never be updated. A package can be pinned using pin, for example:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> pin Example\n Resolving package versions...\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7876af07] ~ Example v0.5.1 ⇒ v0.5.1 ⚲","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Note the pin symbol ⚲ showing that the package is pinned. Removing the pin is done using free","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> free Example\n  Updating `~/.julia/environments/v1.0/Project.toml`\n  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1\n  Updating `~/.julia/environments/v1.0/Manifest.toml`\n  [7876af07] ~ Example v0.5.1 ⚲ ⇒ v0.5.1","category":"page"},{"location":"managing-packages/#Testing-packages","page":"3. Managing Packages","title":"Testing packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The tests for a package can be run using testcommand:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> test Example\n   Testing Example\n   Testing Example tests passed","category":"page"},{"location":"managing-packages/#Building-packages","page":"3. Managing Packages","title":"Building packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The build step of a package is automatically run when a package is first installed. The output of the build process is directed to a file. To explicitly run the build step for a package, the build command is used:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> build MbedTLS\n  Building MbedTLS → `~/.julia/packages/MbedTLS/h1Vu/deps/build.log`\n\njulia> print(read(\"~/.julia/packages/MbedTLS/h1Vu/deps/build.log\", String))\n┌ Warning: `wait(t::Task)` is deprecated, use `fetch(t)` instead.\n│   caller = macro expansion at OutputCollector.jl:63 [inlined]\n└ @ Core OutputCollector.jl:63\n...\n[ Info: using prebuilt binaries","category":"page"},{"location":"managing-packages/#conflicts","page":"3. Managing Packages","title":"Interpreting and resolving version conflicts","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"An environment consists of a set of mutually-compatible packages. Sometimes, you can find yourself in a situation in which two packages you'd like to use simultaneously have incompatible requirements. In such cases you'll get an \"Unsatisfiable requirements\" error:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"using Pkg\ninclude(joinpath(pkgdir(Pkg), \"test\", \"resolve_utils.jl\"))\nusing .ResolveUtils\ndeps_data = Any[[\"A\", v\"1.0.0\", \"C\", v\"0.2\"],\n                [\"B\", v\"1.0.0\", \"D\", v\"0.1\"],\n                [\"C\", v\"0.1.0\", \"D\", v\"0.1\"],\n                [\"C\", v\"0.1.1\", \"D\", v\"0.1\"],\n                [\"C\", v\"0.2.0\", \"D\", v\"0.2\"],\n                [\"D\", v\"0.1.0\"],\n                [\"D\", v\"0.2.0\"],\n                [\"D\", v\"0.2.1\"]]\nreqs_data = Any[[\"A\", \"*\"],\n                [\"B\", \"*\"]]","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"print(\"pkg> add A\\n\", try resolve_tst(deps_data, reqs_data) catch e sprint(showerror, e) end)   # hide","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"This message means that a package named D has a version conflict. Even if you have never added D directly, this kind of error can arise if D is required by other packages that you are trying to use.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The error message has a lot of crucial information. It may be easiest to interpret piecewise:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Unsatisfiable requirements detected for package D [756980fe]:\n D [756980fe] log:\n ├─possible versions are: [0.1.0, 0.2.0-0.2.1] or uninstalled","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"means that D has three released versions, v0.1.0, v0.2.0, and v0.2.1. You also have the option of not having it installed at all. Each of these options might have different implications for the set of other packages that can be installed.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Crucially, notice the stroke characters (vertical and horizontal lines) and their indentation. Together, these connect messages to specific packages. For instance the right stroke of ├─ indicates that the message to its right (possible versions...) is connected to the package pointed to by its vertical stroke (D). This same principle applies to the next line:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":" ├─restricted by compatibility requirements with B [f4259836] to versions: 0.1.0","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The vertical stroke here is also aligned under D, and thus this message is in reference to D. Specifically, there's some other package B that depends on version v0.1.0 of D. Notice that this is not the newest version of D.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Next comes some information about B:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":" │ └─B [f4259836] log:\n │   ├─possible versions are: 1.0.0 or uninstalled\n │   └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The two lines below the first have a vertical stroke that aligns with B, and thus they provide information about B. They tell you that B has just one release, v1.0.0. You've not specified a particular version of B (restricted to versions * means that any version will do), but the explicit requirement means that you've asked for B to be part of your environment, for example by pkg> add B. You might have asked for B previously, and the requirement is still active.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The conflict becomes clear with the line","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"└─restricted by compatibility requirements with C [c99a7cb2] to versions: 0.2.0 — no versions left","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Here again the vertical stroke aligns with D: this means that D is also required by another package, C. C requires v0.2.0 of D, and this conflicts with B's need for v0.1.0 of D. This explains the conflict.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"But wait, you might ask, what is C and why do I need it at all? The next few lines introduce the problem:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"   └─C [c99a7cb2] log:\n     ├─possible versions are: [0.1.0-0.1.1, 0.2.0] or uninstalled\n     └─restricted by compatibility requirements with A [29c70717] to versions: 0.2.0","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"These provide more information about C, revealing that it has 3 released versions: v0.1.0, v0.1.1, and v0.2.0. Moreover, C is required by another package A. Indeed, A's requirements are such that we need v0.2.0 of C. A's origin is revealed on the next lines:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"       └─A [29c70717] log:\n         ├─possible versions are: 1.0.0 or uninstalled\n         └─restricted to versions * by an explicit requirement, leaving only versions 1.0.0","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"So we can see that A was explicitly required, and in this case it's because we were trying to add it to our environment.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"In summary, we explicitly asked to use A and B, but this gave a conflict for D. The reason was that B and C require conflicting versions of D. Even though C isn't something we asked for explicitly, it was needed by A.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"To fix such errors, you have a number of options:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"try updating your packages. It's possible the developers of these packages have recently released new versions that are mutually compatible.\nremove either A or B from your environment. Perhaps B is left over from something you were previously working on, and you don't need it anymore. If you don't need A and B at the same time, this is the easiest way to fix the problem.\ntry reporting your conflict. In this case, we were able to deduce that B requires an outdated version of D. You could thus report an issue in the development repository of B.jl asking for an updated version.\ntry fixing the problem yourself. This becomes easier once you understand Project.toml files and how they declare their compatiblity requirements. We'll return to this example in Fixing conflicts.","category":"page"},{"location":"managing-packages/#Garbage-collecting-old,-unused-packages","page":"3. Managing Packages","title":"Garbage collecting old, unused packages","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"As packages are updated and projects are deleted, installed package versions and artifacts that were once used will inevitably become old and not used from any existing project. Pkg keeps a log of all projects used so it can go through the log and see exactly which projects still exist and what packages/artifacts those projects used. If a package or artifact is not marked as used by any project, it is added to a list of orphaned packages. Packages and artifacts that are in the orphan list for 30 days without being used again are deleted from the system on the next garbage collection. This timing is configurable via the collect_delay keyword argument to Pkg.gc(). A value of 0 will cause anything currently not in use immediately, skipping the orphans list entirely; If you are short on disk space and want to clean out as many unused packages and artifacts as possible, you may want to try this, but if you need these versions again, you will have to download them again. To run a typical garbage collection with default arguments, simply use the gc command at the pkg> REPL:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"(v1.0) pkg> gc\n    Active manifests at:\n        `~/BinaryProvider/Manifest.toml`\n        ...\n        `~/Compat.jl/Manifest.toml`\n    Active artifacts:\n        `~/src/MyProject/Artifacts.toml`\n\n    Deleted ~/.julia/packages/BenchmarkTools/1cAj: 146.302 KiB\n    Deleted ~/.julia/packages/Cassette/BXVB: 795.557 KiB\n   ...\n   Deleted `~/.julia/artifacts/e44cdf2579a92ad5cbacd1cddb7414c8b9d2e24e` (152.253 KiB)\n   Deleted `~/.julia/artifacts/f2df5266567842bbb8a06acca56bcabf813cd73f` (21.536 MiB)\n\n   Deleted 36 package installations (113.205 MiB)\n   Deleted 15 artifact installations (20.759 GiB)","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Note that only packages in ~/.julia/packages are deleted.","category":"page"},{"location":"managing-packages/#Pkg-client/server","page":"3. Managing Packages","title":"Pkg client/server","text":"","category":"section"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"compat: Julia 1.4\nPkg client/server feature requires at least Julia 1.4. It is opt-in for Julia 1.4 and is enabled by default since Julia 1.5.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"When you add a new registered package, usually three things would happen:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"update registries,\ndownload source codes of the package,\nif not available, download artifacts required by the package.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"The General registry and most packages in it are developed on Github, while the artifacts data are hosted in various platforms. When the network connection to Github and AWS S3 is not stable, it is usually not a good experience to install or update packages. Fortunately, the pkg client/server feature improves the experience in the sense that:","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"If set, pkg client would first try to download data from the pkg server,\nif that fails, then it falls back to download from the origianl sources (e.g., Github).","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"Since Julia 1.5, https://pkg.julialang.org provided by the JuliaLang org. is used as the default pkg server. In most cases this should be transparent, but users can still set/unset an pkg server upstream via the environment variable JULIA_PKG_SERVER.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"# manually set it to some pkg server\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"pkg.julialang.org\"\n\"pkg.julialang.org\"\n\n# unset to always download data from original sources\njulia> ENV[\"JULIA_PKG_SERVER\"] = \"\"\n\"\"","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"For clarification, some sources are not provided by Pkg server","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"packages/registries fetched via git\n]add https://github.com/JuliaLang/Example.jl.git\n]add Example#v0.5.3 (Note that this is different from ]add Example@0.5.3)\n]registry add https://github.com/JuliaRegistries/General.git, including registries installed by Julia before 1.4.\nartifacts without download info\nTestImages","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"note: Note\nIf you have a new registry installed via pkg server, then it's impossible for old Julia versions to update the registry because Julia before 1.4 don't know how to fetch new data. Hence, for users that frequently switches between multiple julia versions, it is recommended to still use git-controlled regsitries.","category":"page"},{"location":"managing-packages/","page":"3. Managing Packages","title":"3. Managing Packages","text":"For the deployment of pkg server, please refer to PkgServer.jl.","category":"page"},{"location":"environments/#**4.**-Working-with-Environments","page":"4. Working with Environments","title":"4. Working with Environments","text":"","category":"section"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"The following discusses Pkg's interaction with environments. For more on the role environments play in code loading, including the \"stack\" of environments from which code can be loaded, see this section in the Julia manual.","category":"page"},{"location":"environments/#Creating-your-own-projects","page":"4. Working with Environments","title":"Creating your own projects","text":"","category":"section"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"So far we have added packages to the default project at ~/.julia/environments/v1.0. It is however easy to create other, independent, projects. It should be pointed out that when two projects use the same package at the same version, the content of this package is not duplicated. In order to create a new project, create a directory for it and then activate that directory to make it the \"active project\", which package operations manipulate:","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"julia> mkdir(\"MyProject\")\n\njulia> cd(\"MyProject\")\n/Users/kristoffer/MyProject\n\n(v1.0) pkg> activate .\n\n(MyProject) pkg> st\n    Status `Project.toml`","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"Note that the REPL prompt changed when the new project is activated. Since this is a newly created project, the status command shows that it contains no packages, and in fact, it has no project or manifest file until we add a package to it:","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"julia> readdir()\n0-element Array{String,1}\n\n(MyProject) pkg> add Example\n  Updating registry at `~/.julia/registries/General`\n  Updating git-repo `https://github.com/JuliaRegistries/General.git`\n Resolving package versions...\n  Updating `Project.toml`\n  [7876af07] + Example v0.5.1\n  Updating `Manifest.toml`\n  [7876af07] + Example v0.5.1\n  [8dfed614] + Test\nPrecompiling project...\n  1 dependency successfully precompiled in 2 seconds\n\njulia> readdir()\n2-element Array{String,1}:\n \"Manifest.toml\"\n \"Project.toml\"\n\njulia> print(read(\"Project.toml\", String))\n[deps]\nExample = \"7876af07-990d-54b4-ab0e-23690620f79a\"\n\njulia> print(read(\"Manifest.toml\", String))\n[[Example]]\ndeps = [\"Test\"]\ngit-tree-sha1 = \"8eb7b4d4ca487caade9ba3e85932e28ce6d6e1f8\"\nuuid = \"7876af07-990d-54b4-ab0e-23690620f79a\"\nversion = \"0.5.1\"\n\n[[Test]]\nuuid = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"This new environment is completely separate from the one we used earlier.","category":"page"},{"location":"environments/#Project-Precompilation","page":"4. Working with Environments","title":"Project Precompilation","text":"","category":"section"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"By default any package that is added to a project or updated in a Pkg action will be automatically precompiled, along with its dependencies. The exception is the develop command, which neither builds nor precompiles the package, when that happens is left up to the user to decide.","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"If a package that has been updated is already loaded in the session, the precompilation process will go ahead and precompile the new version, and any packages that depend on it, but will note that the package cannot be used until session restart.","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"To disable this auto-precompilation, set ENV[\"JULIA_PKG_PRECOMPILE_AUTO\"]=0, after which precompilation can be triggered manually either serially via code loading","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"julia> using Example\n[ Info: Precompiling Example [7876af07-990d-54b4-ab0e-23690620f79a]","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"or the parallel precompilation, which can be significantly faster when many dependencies are involved, via","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"pkg> precompile\nPrecompiling project...\n  23 dependencies successfully precompiled in 36 seconds","category":"page"},{"location":"environments/#Using-someone-else's-project","page":"4. Working with Environments","title":"Using someone else's project","text":"","category":"section"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"Simply clone their project using e.g. git clone, cd to the project directory and call","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"(v1.0) pkg> activate .\n\n(SomeProject) pkg> instantiate","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"If the project contains a manifest, this will install the packages in the same state that is given by that manifest. Otherwise, it will resolve the latest versions of the dependencies compatible with the project.","category":"page"},{"location":"environments/","page":"4. Working with Environments","title":"4. Working with Environments","text":"note: Specifying project on startup\nInstead of using activate from within Julia you can specify the project on startup using the --project=<path> flag. For example, to run a script from the command line using the environment in the current directory you can run$ julia --project=. myscript.jl","category":"page"},{"location":"creating-packages/#**5.**-Creating-Packages","page":"5. Creating Packages","title":"5. Creating Packages","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"A package is a project with a name, uuid and version entry in the Project.toml file, and a src/PackageName.jl file that defines the module PackageName. This file is executed when the package is loaded.","category":"page"},{"location":"creating-packages/#Generating-files-for-a-package","page":"5. Creating Packages","title":"Generating files for a package","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"note: Note\nThe PkgTemplates package offers a very easy, repeatable, and  customizable way to generate the files for a new package. We recommend that you use PkgTemplates for creating new packages instead of using the minimal pkg> generate functionality described below.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"To generate files for a new package, use pkg> generate.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"(v1.0) pkg> generate HelloWorld","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"This creates a new project HelloWorld with the following files (visualized with the external tree command):","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"julia> cd(\"HelloWorld\")\n\nshell> tree .\n.\n├── Project.toml\n└── src\n    └── HelloWorld.jl\n\n1 directory, 2 files","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"The Project.toml file contains the name of the package, its unique UUID, its version, the authors and potential dependencies:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"name = \"HelloWorld\"\nuuid = \"b4cd1eb8-1e24-11e8-3319-93036a3eb9f3\"\nversion = \"0.1.0\"\nauthors = [\"Some One <someone@email.com>\"]\n\n[deps]","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"The content of src/HelloWorld.jl is:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"module HelloWorld\n\ngreet() = print(\"Hello World!\")\n\nend # module","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"We can now activate the project and load the package:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"pkg> activate .\n\njulia> import HelloWorld\n\njulia> HelloWorld.greet()\nHello World!","category":"page"},{"location":"creating-packages/#Adding-dependencies-to-the-project","page":"5. Creating Packages","title":"Adding dependencies to the project","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Let’s say we want to use the standard library package Random and the registered package JSON in our project. We simply add these packages (note how the prompt now shows the name of the newly generated project, since we activated it):","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"(HelloWorld) pkg> add Random JSON\n Resolving package versions...\n  Updating \"~/Documents/HelloWorld/Project.toml\"\n [682c06a0] + JSON v0.17.1\n [9a3f8284] + Random\n  Updating \"~/Documents/HelloWorld/Manifest.toml\"\n [34da2185] + Compat v0.57.0\n [682c06a0] + JSON v0.17.1\n [4d1e1d77] + Nullables v0.0.4\n ...","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Both Random and JSON got added to the project’s Project.toml file, and the resulting dependencies got added to the Manifest.toml file. The resolver has installed each package with the highest possible version, while still respecting the compatibility that each package enforces on its dependencies.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"We can now use both Random and JSON in our project. Changing src/HelloWorld.jl to","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"module HelloWorld\n\nimport Random\nimport JSON\n\ngreet() = print(\"Hello World!\")\ngreet_alien() = print(\"Hello \", Random.randstring(8))\n\nend # module","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"and reloading the package, the new greet_alien function that uses Random can be called:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"julia> HelloWorld.greet_alien()\nHello aT157rHV","category":"page"},{"location":"creating-packages/#Adding-a-build-step-to-the-package","page":"5. Creating Packages","title":"Adding a build step to the package","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"The build step is executed the first time a package is installed or when explicitly invoked with build. A package is built by executing the file deps/build.jl.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"julia> print(read(\"deps/build.jl\", String))\nprintln(\"I am being built...\")\n\n(HelloWorld) pkg> build\n  Building HelloWorld → `deps/build.log`\n Resolving package versions...\n\njulia> print(read(\"deps/build.log\", String))\nI am being built...","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"If the build step fails, the output of the build step is printed to the console","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"julia> print(read(\"deps/build.jl\", String))\nerror(\"Ooops\")\n\n(HelloWorld) pkg> build\n  Building HelloWorld → `deps/build.log`\n Resolving package versions...\n┌ Error: Error building `HelloWorld`:\n│ ERROR: LoadError: Ooops\n│ Stacktrace:\n│  [1] error(::String) at ./error.jl:33\n│  [2] top-level scope at none:0\n│  [3] include at ./boot.jl:317 [inlined]\n│  [4] include_relative(::Module, ::String) at ./loading.jl:1071\n│  [5] include(::Module, ::String) at ./sysimg.jl:29\n│  [6] include(::String) at ./client.jl:393\n│  [7] top-level scope at none:0\n│ in expression starting at /Users/kristoffer/.julia/dev/Pkg/HelloWorld/deps/build.jl:1\n└ @ Pkg.Operations Operations.jl:938","category":"page"},{"location":"creating-packages/#Adding-tests-to-the-package","page":"5. Creating Packages","title":"Adding tests to the package","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"When a package is tested the file test/runtests.jl is executed:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"julia> print(read(\"test/runtests.jl\", String))\nprintln(\"Testing...\")\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\nTesting...\n   Testing HelloWorld tests passed","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Tests are run in a new Julia process, where the package itself, and any test-specific dependencies, are available, see below.","category":"page"},{"location":"creating-packages/#Test-specific-dependencies-in-Julia-1.2-and-above","page":"5. Creating Packages","title":"Test-specific dependencies in Julia 1.2 and above","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"compat: Julia 1.2\nThis section only applies to Julia 1.2 and above. For specifying test dependencies on previous Julia versions, see Test-specific dependencies in Julia 1.0 and 1.1.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"note: Note\nThe exact interaction between Project.toml, test/Project.toml and their corresponding Manifest.tomls are not fully worked out, and may be subject to change in future versions. The old method of adding test-specific dependencies, described in the next section, will therefore be supported throughout all Julia 1.X releases.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"In Julia 1.2 and later the test environment is given by test/Project.toml. Thus, when running tests, this will be the active project, and only dependencies to the test/Project.toml project can be used. Note that Pkg will add the tested package itself implictly.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"note: Note\nIf no test/Project.toml exists Pkg will use the old style test-setup, as described in Test-specific dependencies in Julia 1.0 and 1.1.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"To add a test-specific dependency, i.e. a dependency that is available only when testing, it is thus enough to add this dependency to the test/Project.toml project. This can be done from the Pkg REPL by activating this environment, and then use add as one normally does. Lets add the Test standard library as a test dependency:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"(HelloWorld) pkg> activate ./test\n[ Info: activating environment at `~/HelloWorld/test/Project.toml`.\n\n(test) pkg> add Test\n Resolving package versions...\n  Updating `~/HelloWorld/test/Project.toml`\n  [8dfed614] + Test\n  Updating `~/HelloWorld/test/Manifest.toml`\n  [...]","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"We can now use Test in the test script and we can see that it gets installed when testing:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"julia> print(read(\"test/runtests.jl\", String))\nusing Test\n@test 1 == 1\n\n(HelloWorld) pkg> test\n   Testing HelloWorld\n Resolving package versions...\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Project.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n  [8dfed614] + Test\n  Updating `/var/folders/64/76tk_g152sg6c6t0b4nkn1vw0000gn/T/tmpPzUPPw/Manifest.toml`\n  [d8327f2a] + HelloWorld v0.1.0 [`~/.julia/dev/Pkg/HelloWorld`]\n   Testing HelloWorld tests passed```","category":"page"},{"location":"creating-packages/#Test-specific-dependencies-in-Julia-1.0-and-1.1","page":"5. Creating Packages","title":"Test-specific dependencies in Julia 1.0 and 1.1","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"note: Note\nThe method of adding test-specific dependencies described in this section will be replaced by the method from the previous section in future Julia versions. The method in this section will, however, be supported throughout all Julia 1.X releases.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"In Julia 1.0 and Julia 1.1 test-specific dependencies are added to the main Project.toml. To add Markdown and Test as test-dependencies, add the following:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"[extras]\nMarkdown = \"d6f4376e-aef5-505a-96c1-9c027394607a\"\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Markdown\", \"Test\"]","category":"page"},{"location":"creating-packages/#Package-naming-guidelines","page":"5. Creating Packages","title":"Package naming guidelines","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Package names should be sensible to most Julia users, even to those who are not domain experts. The following guidelines applies to the General registry, but may be useful for other package registries as well.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Since the General registry belongs to the entire community, people may have opinions about your package name when you publish it, especially if it's ambiguous or can be confused with something other than what it is. Usually you will then get suggestions for a new name that may fit your package better.","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Avoid jargon. In particular, avoid acronyms unless there is minimal possibility of confusion.\nIt's ok to say USA if you're talking about the USA.\nIt's not ok to say PMA, even if you're talking about positive mental attitude.\nAvoid using Julia in your package name or prefixing it with Ju.\nIt is usually clear from context and to your users that the package is a Julia package.\nPackage names already have a .jl extension, which communicates to users that Package.jl is a Julia package.\nHaving Julia in the name can imply that the package is connected to, or endorsed by, contributors to the Julia language itself.\nPackages that provide most of their functionality in association with a new type should have pluralized names.\nDataFrames provides the DataFrame type.\nBloomFilters provides the BloomFilter type.\nIn contrast, JuliaParser provides no new type, but instead new functionality in the JuliaParser.parse() function.\nErr on the side of clarity, even if clarity seems long-winded to you.\nRandomMatrices is a less ambiguous name than RndMat or RMT, even though the latter are shorter.\nA less systematic name may suit a package that implements one of several possible approaches to its domain.\nJulia does not have a single comprehensive plotting package. Instead, Gadfly, PyPlot, Winston and other packages each implement a unique approach based on a particular design philosophy.\nIn contrast, SortingAlgorithms provides a consistent interface to use many well-established sorting algorithms.\nPackages that wrap external libraries or programs should be named after those libraries or programs.\nCPLEX.jl wraps the CPLEX library, which can be identified easily in a web search.\nMATLAB.jl provides an interface to call the MATLAB engine from within Julia.\nAvoid naming a package closely to an existing package\nWebsocket is too close to WebSockets and can be confusing to users. Rather use a new name such as SimpleWebsockets.","category":"page"},{"location":"creating-packages/#Registering-packages","page":"5. Creating Packages","title":"Registering packages","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Once a package is ready it can be registered with the General Registry. Currently packages are submitted via Registrator. In addition to Registrator, TagBot helps manage the process of tagging releases.","category":"page"},{"location":"creating-packages/#Best-Practices","page":"5. Creating Packages","title":"Best Practices","text":"","category":"section"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Packages should avoid mutating their own state (writing to files within their package directory). Packages should, in general, not assume that they are located in a writable location (e.g. if installed as part of a system-wide depot) or even a stable one (e.g. if they are bundled into a system image by PackageCompiler.jl). To support the various usecases in the Julia package ecosystem, the Pkg developers have created a number of auxilliary packages and techniques to help package authors create self-contained, immutable and relocatable packages:","category":"page"},{"location":"creating-packages/","page":"5. Creating Packages","title":"5. Creating Packages","text":"Artifacts can be used to bundle chunks of data alongside your package, or even allow them to be downloaded on-demand. Prefer artifacts over attempting to open a file via a path such as joinpath(@__DIR__, \"data\", \"my_dataset.csv\") as this is non-relocatable. Once your package has been precompiled, the result of @__DIR__ will have been baked into your precompiled package data, and if you attempt to distribute this package, it will attempt to load files at the wrong location. Artifacts can be bundled and accessed easily using the artifact\"name\" string macro. Artifacts are available from Julia 1.3 onward.\nScratch.jl provides the notion of \"scratch spaces\", mutable containers of data for packages. Scratch spaces are designed for data caches that are completely managed by a package and should be removed when the package itself is uninstalled. For important user-generated data, packages should continue to write out to a user-specified path that is not managed by Julia or Pkg. Scratch is usable from Julia 1.5 onward.\nPreferences.jl allows packages to read and write preferences to the top-level Project.toml. These preferences can be read at runtime or compile-time, to enable or disable different aspects of package behavior. Packages previously would write out files to their own package directories to record options set by the user or environment, but this is highly discouraged now that Preferences is available. Preferences are available from Juilia 1.6 onward.","category":"page"},{"location":"repl/#REPL-Mode-Reference","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"","category":"section"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"This section describes available commands in the Pkg REPL. The Pkg REPL mode is mostly meant for interactive use, and for non-interactive use it is recommended to use the functional API, see API Reference.","category":"page"},{"location":"repl/#package-commands","page":"11. REPL Mode Reference","title":"package commands","text":"","category":"section"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-add\" href=\"#repl-add\">\n            <code>add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"add\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-build\" href=\"#repl-build\">\n            <code>build</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"build\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-develop\" href=\"#repl-develop\">\n            <code>develop</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"develop\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-free\" href=\"#repl-free\">\n            <code>free</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"free\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-generate\" href=\"#repl-generate\">\n            <code>generate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"generate\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-pin\" href=\"#repl-pin\">\n            <code>pin</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"pin\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-remove\" href=\"#repl-remove\">\n            <code>remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"remove\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-test\" href=\"#repl-test\">\n            <code>test</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"test\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-update\" href=\"#repl-update\">\n            <code>update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"update\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/#registry-commands","page":"11. REPL Mode Reference","title":"registry commands","text":"","category":"section"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-add\" href=\"#repl-registry-add\">\n            <code>registry add</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry add\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-remove\" href=\"#repl-registry-remove\">\n            <code>registry remove</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry remove\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-status\" href=\"#repl-registry-status\">\n            <code>registry status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry status\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-registry-update\" href=\"#repl-registry-update\">\n            <code>registry update</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"registry update\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/#Other-commands","page":"11. REPL Mode Reference","title":"Other commands","text":"","category":"section"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-activate\" href=\"#repl-activate\">\n            <code>activate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"activate\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-gc\" href=\"#repl-gc\">\n            <code>gc</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"gc\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-help\" href=\"#repl-help\">\n            <code>help</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"help\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-instantiate\" href=\"#repl-instantiate\">\n            <code>instantiate</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"instantiate\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-precompile\" href=\"#repl-precompile\">\n            <code>precompile</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"precompile\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-resolve\" href=\"#repl-resolve\">\n            <code>resolve</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"resolve\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"<article class=\"docstring\">\n    <header>\n        <a class=\"docstring-binding\" id=\"repl-status\" href=\"#repl-status\">\n            <code>status</code>\n        </a>\n        —\n        <span class=\"docstring-category\">REPL command</span>\n    </header>\n    <section>","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"using Pkg\nDict(Pkg.REPLMode.canonical_names())[\"status\"].help","category":"page"},{"location":"repl/","page":"11. REPL Mode Reference","title":"11. REPL Mode Reference","text":"    </section>\n</article>","category":"page"},{"location":"#**1.**-Introduction","page":"1. Introduction","title":"1. Introduction","text":"","category":"section"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Welcome to the documentation for Pkg, Julia's package manager. The documentation covers many things, for example managing package installations, developing packages, working with package registries and more.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Throughout the manual the REPL interface to Pkg, the Pkg REPL mode, is used in the examples. There is also a functional API, which is preferred when not working interactively. This API is documented in the API Reference section.","category":"page"},{"location":"#Background-and-Design","page":"1. Introduction","title":"Background and Design","text":"","category":"section"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Pkg is a complete rewrite of Julia's old package manager[1] and was released together with Julia v1.0. Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around “environments”: independent sets of packages that can be local to an individual project or shared and selected by name. The exact set of packages and versions in an environment is captured in a manifest file which can be checked into a project repository and tracked in version control, significantly improving reproducibility of projects. If you’ve ever tried to run code you haven’t used in a while only to find that you can’t get anything to work because you’ve updated or uninstalled some of the packages your project was using, you’ll understand the motivation for this approach. In Pkg, since each project maintains its own independent set of package versions, you’ll never have this problem again. Moreover, if you check out a project on a new system, you can simply materialize the environment described by its manifest file and immediately be up and running with a known-good set of dependencies.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Since environments are managed and updated independently from each other, “dependency hell” is significantly alleviated in Pkg. If you want to use the latest and greatest version of some package in a new project but you’re stuck on an older version in a different project, that’s no problem – since they have separate environments they can just use different versions, which are both installed at the same time in different locations on your system. The location of each package version is canonical, so when environments use the same versions of packages, they can share installations, avoiding unnecessary duplication of the package. Old package versions that are no longer used by any environments are periodically “garbage collected” by the package manager.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Pkg’s approach to local environments may be familiar to people who have used Python’s virtualenv or Ruby’s bundler. In Julia, instead of hacking the language’s code loading mechanisms to support environments, we have the benefit that Julia natively understands them. In addition, Julia environments are “stackable”: you can overlay one environment with another and thereby have access to additional packages outside of the primary environment. This makes it easy to work on a project, which provides the primary environment, while still having access from the REPL to all your usual dev tools like profilers, debuggers, and so on, just by having an environment including these dev tools later in the load path.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Last but not least, Pkg is designed to support federated package registries. This means that it allows multiple registries managed by different parties to interact seamlessly. In particular, this includes private registries which can live behind corporate firewalls. You can install and update your own packages from a private registry with exactly the same tools and workflows that you use to install and manage official Julia packages. If you urgently need to apply a hotfix for a public package that’s critical to your company’s product, you can tag a private version of it in your company’s internal registry and get a fix to your developers and ops teams quickly and easily without having to wait for an upstream patch to be accepted and published. Once an official fix is published, however, you can just upgrade your dependencies and you'll be back on an official release again.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"[1]: Often denoted Pkg2, now archived as OldPkg at   github.com/JuliaAttic/OldPkg.jl.","category":"page"}]
}
